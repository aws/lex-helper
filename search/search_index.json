{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"BEST_PRACTICES/","text":"Lex Helper Library - Best Practices Guide This guide covers detailed usage patterns and best practices for the Lex Helper library. For basic installation and setup, see README.md . Environment Variables The following environment variables can be configured in your Lambda function: MessageManager MESSAGES_YAML_PATH : Custom path to messages YAML file directory bash MESSAGES_YAML_PATH=/opt/lambda/config/messages.yaml AWS Services AWS_REGION : AWS region for services (defaults to us-east-1 ) AWS_DEFAULT_REGION : Alternative AWS region setting Python/Lambda PYTHONPATH : Additional Python module search paths LOG_LEVEL : Logging level ( DEBUG , INFO , WARNING , ERROR ) Example Lambda Environment Configuration # In AWS Lambda Console or CloudFormation MESSAGES_YAML_PATH=/opt/lambda/messages/ AWS_REGION=us-west-2 LOG_LEVEL=INFO Message Management Setting Up Localized Messages Create locale-specific message files in your Lambda function: your_lambda/ \u251c\u2500\u2500 messages_en_US.yaml \u251c\u2500\u2500 messages_es_ES.yaml \u251c\u2500\u2500 messages_fr_FR.yaml \u2514\u2500\u2500 messages.yaml # fallback Using MessageManager from lex_helper import set_locale, get_message def lambda_handler(event, context): # Set locale from Lex event locale_id = event.get('bot', {}).get('localeId', 'en_US') set_locale(locale_id) # Get localized messages greeting = get_message(\"greeting\") error_msg = get_message(\"error.general\", \"Something went wrong\") # Override locale for specific message spanish_greeting = get_message(\"greeting\", locale=\"es_ES\") Message File Structure # messages_en_US.yaml greeting: \"Hello! How can I assist you today?\" agent: confirmation: \"I understand you'd like to chat with an agent...\" transfer: \"Connecting you to an agent now.\" error: general: \"I apologize, but I encountered an error.\" validation: \"Please provide valid information.\" # messages_es_ES.yaml greeting: \"\u00a1Hola! \u00bfC\u00f3mo puedo ayudarte hoy?\" agent: confirmation: \"Entiendo que te gustar\u00eda hablar con un agente...\" transfer: \"Te estoy conectando con un agente ahora.\" error: general: \"Me disculpo, pero encontr\u00e9 un error.\" validation: \"Por favor proporciona informaci\u00f3n v\u00e1lida.\" Using Dialog Utilities Import required functions from the dialog module: from lex_helper import dialog, LexPlainText, get_message def handle_welcome_intent(lex_request): # Set locale from Lex request set_locale(lex_request.bot.localeId) # Check for unknown slot choices first if dialog.any_unknown_slot_choices(lex_request): return dialog.handle_any_unknown_slot_choice(lex_request) # Get slot values user_name = dialog.get_slot(\"user_name\", dialog.get_intent(lex_request)) if not user_name: prompt_message = get_message(\"prompts.name\", \"What's your name?\") return dialog.elicit_slot( slot_to_elicit=\"user_name\", messages=[LexPlainText(content=prompt_message)], lex_request=lex_request ) # Set slot values with localized greeting greeting_template = get_message(\"greeting.personalized\", \"Hello {name}!\") greeting = greeting_template.format(name=user_name) dialog.set_slot(\"user_greeting\", greeting, dialog.get_intent(lex_request)) return dialog.delegate(lex_request) Intent Organization Structure your intents in an intents/ directory: your_project/ \u251c\u2500\u2500 intents/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 welcome_intent.py \u2502 \u251c\u2500\u2500 booking_intent.py \u2502 \u2514\u2500\u2500 fallback_intent.py \u251c\u2500\u2500 session_attributes.py \u2514\u2500\u2500 handler.py Each intent file should contain a handler function matching the intent name. Working with Messages Loading Messages from JSON from lex_helper.core.dialog import load_messages messages_json = '[{\"contentType\": \"PlainText\", \"content\": \"Hello!\"}]' messages = load_messages(messages_json) Creating Messages from lex_helper import LexPlainText, LexImageResponseCard # Plain text message text_msg = LexPlainText(content=\"How can I help you?\") # Image response card with buttons card_msg = LexImageResponseCard( imageResponseCard={ \"title\": \"Choose an option\", \"buttons\": [ {\"text\": \"Option A\", \"value\": \"A\"}, {\"text\": \"Option B\", \"value\": \"B\"} ] } ) Error Handling and Unknown Choices Handle invalid user responses: def handle_booking_intent(lex_request): # Always check for unknown choices first if dialog.any_unknown_slot_choices(lex_request): return dialog.handle_any_unknown_slot_choice(lex_request) # Your intent logic here return dialog.delegate(lex_request) Intent Transitions Basic Transition return dialog.transition_to_intent( intent_name=\"authenticate\", lex_request=lex_request, messages=[LexPlainText(content=\"Please authenticate first\")] ) Callback Pattern # Set up callback before transitioning lex_request.sessionState.sessionAttributes.callback_handler = lex_request.sessionState.intent.name lex_request.sessionState.sessionAttributes.callback_event = json.dumps(lex_request, default=str) # Transition to authentication return dialog.transition_to_intent( intent_name=\"authenticate\", lex_request=lex_request, messages=[LexPlainText(content=\"Authentication required\")] ) # In the authentication intent, return to original: return dialog.callback_original_intent_handler(lex_request) Best Practices Code Organization Keep intent handlers focused on business logic Use one file per intent in the intents/ directory Implement custom session attributes for type safety Error Handling Always check for unknown slot choices at the start of intent handlers Implement comprehensive error handling with try-catch blocks Use the provided dialog utilities for consistent responses Type Safety Use type hints consistently throughout your code Define custom session attributes with Pydantic models Leverage IDE autocomplete with proper typing Testing Test your bot across different channels (SMS, web, voice) Validate slot elicitation and dialog flows Test error scenarios and fallback behaviors Performance Use the delegate function when Lex can handle the dialog Minimize session attribute size for better performance Cache frequently accessed data appropriately Advanced Usage Custom Unknown Choice Handling def custom_unknown_choice_handler(lex_request, choice): error_count = getattr(lex_request.sessionState.sessionAttributes, 'error_count', 0) if error_count > 2: return dialog.transition_to_intent(\"human_agent\", lex_request, [LexPlainText(content=\"Let me connect you to an agent\")]) return dialog.elicit_slot(\"destination\", [LexPlainText(content=\"Please choose A, B, or C\")], lex_request) Context Management # Remove specific contexts contexts = dialog.remove_context(lex_request.sessionState.activeContexts, \"unwanted_context\") # Get active contexts active_contexts = dialog.get_active_contexts(lex_request) Examples and References Basic Example : See examples/basic_handler/ for a simple implementation Comprehensive Example : Check out the Airline-Bot for production-ready patterns including: Advanced intent organization and management Complex session attribute handling Multi-turn conversation flows Error handling and fallback strategies Best practices for bot architecture Production deployment patterns Common Patterns Slot Validation def validate_email_slot(lex_request): email = dialog.get_slot(\"email\", dialog.get_intent(lex_request)) if email and \"@\" not in email: return dialog.elicit_slot(\"email\", [LexPlainText(content=\"Please enter a valid email\")], lex_request) return dialog.delegate(lex_request) Session State Management def track_conversation_state(lex_request): session_attrs = lex_request.sessionState.sessionAttributes session_attrs.visit_count += 1 session_attrs.last_intent = lex_request.sessionState.intent.name Remember to consult the library documentation and example implementations for detailed information on each utility function and advanced usage scenarios.","title":"Lex Helper Library - Best Practices Guide"},{"location":"BEST_PRACTICES/#lex-helper-library-best-practices-guide","text":"This guide covers detailed usage patterns and best practices for the Lex Helper library. For basic installation and setup, see README.md .","title":"Lex Helper Library - Best Practices Guide"},{"location":"BEST_PRACTICES/#environment-variables","text":"The following environment variables can be configured in your Lambda function:","title":"Environment Variables"},{"location":"BEST_PRACTICES/#messagemanager","text":"MESSAGES_YAML_PATH : Custom path to messages YAML file directory bash MESSAGES_YAML_PATH=/opt/lambda/config/messages.yaml","title":"MessageManager"},{"location":"BEST_PRACTICES/#aws-services","text":"AWS_REGION : AWS region for services (defaults to us-east-1 ) AWS_DEFAULT_REGION : Alternative AWS region setting","title":"AWS Services"},{"location":"BEST_PRACTICES/#pythonlambda","text":"PYTHONPATH : Additional Python module search paths LOG_LEVEL : Logging level ( DEBUG , INFO , WARNING , ERROR )","title":"Python/Lambda"},{"location":"BEST_PRACTICES/#example-lambda-environment-configuration","text":"# In AWS Lambda Console or CloudFormation MESSAGES_YAML_PATH=/opt/lambda/messages/ AWS_REGION=us-west-2 LOG_LEVEL=INFO","title":"Example Lambda Environment Configuration"},{"location":"BEST_PRACTICES/#message-management","text":"","title":"Message Management"},{"location":"BEST_PRACTICES/#setting-up-localized-messages","text":"Create locale-specific message files in your Lambda function: your_lambda/ \u251c\u2500\u2500 messages_en_US.yaml \u251c\u2500\u2500 messages_es_ES.yaml \u251c\u2500\u2500 messages_fr_FR.yaml \u2514\u2500\u2500 messages.yaml # fallback","title":"Setting Up Localized Messages"},{"location":"BEST_PRACTICES/#using-messagemanager","text":"from lex_helper import set_locale, get_message def lambda_handler(event, context): # Set locale from Lex event locale_id = event.get('bot', {}).get('localeId', 'en_US') set_locale(locale_id) # Get localized messages greeting = get_message(\"greeting\") error_msg = get_message(\"error.general\", \"Something went wrong\") # Override locale for specific message spanish_greeting = get_message(\"greeting\", locale=\"es_ES\")","title":"Using MessageManager"},{"location":"BEST_PRACTICES/#message-file-structure","text":"# messages_en_US.yaml greeting: \"Hello! How can I assist you today?\" agent: confirmation: \"I understand you'd like to chat with an agent...\" transfer: \"Connecting you to an agent now.\" error: general: \"I apologize, but I encountered an error.\" validation: \"Please provide valid information.\" # messages_es_ES.yaml greeting: \"\u00a1Hola! \u00bfC\u00f3mo puedo ayudarte hoy?\" agent: confirmation: \"Entiendo que te gustar\u00eda hablar con un agente...\" transfer: \"Te estoy conectando con un agente ahora.\" error: general: \"Me disculpo, pero encontr\u00e9 un error.\" validation: \"Por favor proporciona informaci\u00f3n v\u00e1lida.\"","title":"Message File Structure"},{"location":"BEST_PRACTICES/#using-dialog-utilities","text":"Import required functions from the dialog module: from lex_helper import dialog, LexPlainText, get_message def handle_welcome_intent(lex_request): # Set locale from Lex request set_locale(lex_request.bot.localeId) # Check for unknown slot choices first if dialog.any_unknown_slot_choices(lex_request): return dialog.handle_any_unknown_slot_choice(lex_request) # Get slot values user_name = dialog.get_slot(\"user_name\", dialog.get_intent(lex_request)) if not user_name: prompt_message = get_message(\"prompts.name\", \"What's your name?\") return dialog.elicit_slot( slot_to_elicit=\"user_name\", messages=[LexPlainText(content=prompt_message)], lex_request=lex_request ) # Set slot values with localized greeting greeting_template = get_message(\"greeting.personalized\", \"Hello {name}!\") greeting = greeting_template.format(name=user_name) dialog.set_slot(\"user_greeting\", greeting, dialog.get_intent(lex_request)) return dialog.delegate(lex_request)","title":"Using Dialog Utilities"},{"location":"BEST_PRACTICES/#intent-organization","text":"Structure your intents in an intents/ directory: your_project/ \u251c\u2500\u2500 intents/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 welcome_intent.py \u2502 \u251c\u2500\u2500 booking_intent.py \u2502 \u2514\u2500\u2500 fallback_intent.py \u251c\u2500\u2500 session_attributes.py \u2514\u2500\u2500 handler.py Each intent file should contain a handler function matching the intent name.","title":"Intent Organization"},{"location":"BEST_PRACTICES/#working-with-messages","text":"","title":"Working with Messages"},{"location":"BEST_PRACTICES/#loading-messages-from-json","text":"from lex_helper.core.dialog import load_messages messages_json = '[{\"contentType\": \"PlainText\", \"content\": \"Hello!\"}]' messages = load_messages(messages_json)","title":"Loading Messages from JSON"},{"location":"BEST_PRACTICES/#creating-messages","text":"from lex_helper import LexPlainText, LexImageResponseCard # Plain text message text_msg = LexPlainText(content=\"How can I help you?\") # Image response card with buttons card_msg = LexImageResponseCard( imageResponseCard={ \"title\": \"Choose an option\", \"buttons\": [ {\"text\": \"Option A\", \"value\": \"A\"}, {\"text\": \"Option B\", \"value\": \"B\"} ] } )","title":"Creating Messages"},{"location":"BEST_PRACTICES/#error-handling-and-unknown-choices","text":"Handle invalid user responses: def handle_booking_intent(lex_request): # Always check for unknown choices first if dialog.any_unknown_slot_choices(lex_request): return dialog.handle_any_unknown_slot_choice(lex_request) # Your intent logic here return dialog.delegate(lex_request)","title":"Error Handling and Unknown Choices"},{"location":"BEST_PRACTICES/#intent-transitions","text":"","title":"Intent Transitions"},{"location":"BEST_PRACTICES/#basic-transition","text":"return dialog.transition_to_intent( intent_name=\"authenticate\", lex_request=lex_request, messages=[LexPlainText(content=\"Please authenticate first\")] )","title":"Basic Transition"},{"location":"BEST_PRACTICES/#callback-pattern","text":"# Set up callback before transitioning lex_request.sessionState.sessionAttributes.callback_handler = lex_request.sessionState.intent.name lex_request.sessionState.sessionAttributes.callback_event = json.dumps(lex_request, default=str) # Transition to authentication return dialog.transition_to_intent( intent_name=\"authenticate\", lex_request=lex_request, messages=[LexPlainText(content=\"Authentication required\")] ) # In the authentication intent, return to original: return dialog.callback_original_intent_handler(lex_request)","title":"Callback Pattern"},{"location":"BEST_PRACTICES/#best-practices","text":"","title":"Best Practices"},{"location":"BEST_PRACTICES/#code-organization","text":"Keep intent handlers focused on business logic Use one file per intent in the intents/ directory Implement custom session attributes for type safety","title":"Code Organization"},{"location":"BEST_PRACTICES/#error-handling","text":"Always check for unknown slot choices at the start of intent handlers Implement comprehensive error handling with try-catch blocks Use the provided dialog utilities for consistent responses","title":"Error Handling"},{"location":"BEST_PRACTICES/#type-safety","text":"Use type hints consistently throughout your code Define custom session attributes with Pydantic models Leverage IDE autocomplete with proper typing","title":"Type Safety"},{"location":"BEST_PRACTICES/#testing","text":"Test your bot across different channels (SMS, web, voice) Validate slot elicitation and dialog flows Test error scenarios and fallback behaviors","title":"Testing"},{"location":"BEST_PRACTICES/#performance","text":"Use the delegate function when Lex can handle the dialog Minimize session attribute size for better performance Cache frequently accessed data appropriately","title":"Performance"},{"location":"BEST_PRACTICES/#advanced-usage","text":"","title":"Advanced Usage"},{"location":"BEST_PRACTICES/#custom-unknown-choice-handling","text":"def custom_unknown_choice_handler(lex_request, choice): error_count = getattr(lex_request.sessionState.sessionAttributes, 'error_count', 0) if error_count > 2: return dialog.transition_to_intent(\"human_agent\", lex_request, [LexPlainText(content=\"Let me connect you to an agent\")]) return dialog.elicit_slot(\"destination\", [LexPlainText(content=\"Please choose A, B, or C\")], lex_request)","title":"Custom Unknown Choice Handling"},{"location":"BEST_PRACTICES/#context-management","text":"# Remove specific contexts contexts = dialog.remove_context(lex_request.sessionState.activeContexts, \"unwanted_context\") # Get active contexts active_contexts = dialog.get_active_contexts(lex_request)","title":"Context Management"},{"location":"BEST_PRACTICES/#examples-and-references","text":"Basic Example : See examples/basic_handler/ for a simple implementation Comprehensive Example : Check out the Airline-Bot for production-ready patterns including: Advanced intent organization and management Complex session attribute handling Multi-turn conversation flows Error handling and fallback strategies Best practices for bot architecture Production deployment patterns","title":"Examples and References"},{"location":"BEST_PRACTICES/#common-patterns","text":"","title":"Common Patterns"},{"location":"BEST_PRACTICES/#slot-validation","text":"def validate_email_slot(lex_request): email = dialog.get_slot(\"email\", dialog.get_intent(lex_request)) if email and \"@\" not in email: return dialog.elicit_slot(\"email\", [LexPlainText(content=\"Please enter a valid email\")], lex_request) return dialog.delegate(lex_request)","title":"Slot Validation"},{"location":"BEST_PRACTICES/#session-state-management","text":"def track_conversation_state(lex_request): session_attrs = lex_request.sessionState.sessionAttributes session_attrs.visit_count += 1 session_attrs.last_intent = lex_request.sessionState.intent.name Remember to consult the library documentation and example implementations for detailed information on each utility function and advanced usage scenarios.","title":"Session State Management"},{"location":"DEVELOPMENT/","text":"Development Guide This guide covers common development tasks and workflows for the Lex Helper library. Development Environment Setup Initial Setup # Install uv (Python package manager) pip install uv # Install all dependencies including development tools uv sync --dev # Install pre-commit hooks for automated code quality uv run pre-commit install # Verify setup by running tests uv run pytest IDE Configuration VS Code Recommended extensions: - Python - Pylance (for type checking) - Ruff (for linting and formatting) Settings for .vscode/settings.json : { \"python.defaultInterpreterPath\": \".venv/bin/python\", \"python.linting.enabled\": false, \"python.formatting.provider\": \"none\", \"[python]\": { \"editor.defaultFormatter\": \"charliermarsh.ruff\", \"editor.codeActionsOnSave\": { \"source.fixAll.ruff\": true, \"source.organizeImports.ruff\": true } }, \"python.analysis.typeCheckingMode\": \"strict\" } PyCharm Set Python interpreter to .venv/bin/python Install Ruff plugin Configure Ruff as the default formatter Enable type checking in Python settings Common Development Tasks Running Tests # Run all tests uv run pytest # Run tests with coverage report uv run pytest --cov=lex_helper # Run tests with detailed coverage report uv run pytest --cov=lex_helper --cov-report=html # Run specific test file uv run pytest tests/test_handler.py # Run tests matching a pattern uv run pytest -k \"test_dialog\" # Run tests in verbose mode uv run pytest -v Code Quality Checks # Lint code (check for issues) uv run ruff check . # Lint and auto-fix issues uv run ruff check --fix . # Format code uv run ruff format . # Check specific files uv run ruff check lex_helper/core/handler.py # Show what would be formatted (dry run) uv run ruff format --diff . Type Checking # Run type checking pyright # Type check specific files pyright lex_helper/core/handler.py # Type check with verbose output pyright --verbose Pre-commit Hooks # Run pre-commit on staged files uv run pre-commit run # Run pre-commit on all files uv run pre-commit run --all-files # Run specific hook uv run pre-commit run ruff # Update hook versions uv run pre-commit autoupdate Dependency Management # Add new dependency uv add package-name # Add development dependency uv add --dev package-name # Remove dependency uv remove package-name # Update dependencies uv sync # Show dependency tree uv tree # Export requirements (for compatibility) uv export --format requirements-txt > requirements.txt Project Structure Core Components lex_helper/ \u251c\u2500\u2500 __init__.py # Main exports \u251c\u2500\u2500 core/ # Core functionality \u2502 \u251c\u2500\u2500 handler.py # Main LexHelper class \u2502 \u251c\u2500\u2500 types.py # Pydantic models \u2502 \u251c\u2500\u2500 dialog.py # Dialog utilities \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 channels/ # Channel-specific formatting \u251c\u2500\u2500 formatters/ # Text and response formatters \u251c\u2500\u2500 utils/ # Utility functions \u2514\u2500\u2500 exceptions/ # Custom exceptions Testing Structure tests/ \u251c\u2500\u2500 test_handler.py # Handler tests \u251c\u2500\u2500 test_utils.py # Utility tests \u251c\u2500\u2500 test_*.py # Other test files \u2514\u2500\u2500 sample_lex_request.py # Test data Code Style Guidelines Python Code Style Line length : 125 characters Quote style : Double quotes for strings Import organization : Automatic with Ruff Type hints : Required for all public APIs Docstrings : Google style for public functions Example Code Style from typing import Any, Dict, Optional from pydantic import BaseModel, Field from lex_helper.core.types import LexRequest, LexResponse class ExampleModel(BaseModel): \"\"\"Example model with proper type hints and docstrings. Args: name: The name field with validation count: Optional count with default value \"\"\" name: str = Field(..., description=\"Name field\") count: Optional[int] = Field(default=0, description=\"Count field\") def process_data(self, data: Dict[str, Any]) -> Dict[str, Any]: \"\"\"Process the input data and return results. Args: data: Input data dictionary Returns: Processed data dictionary Raises: ValueError: If data is invalid \"\"\" if not data: raise ValueError(\"Data cannot be empty\") return {\"processed\": True, \"original\": data} Testing Guidelines Test Structure import pytest from unittest.mock import Mock, patch from lex_helper import LexHelper, Config from lex_helper.core.types import LexRequest class TestLexHelper: \"\"\"Test class for LexHelper functionality.\"\"\" def setup_method(self): \"\"\"Set up test fixtures before each test method.\"\"\" self.config = Config() self.lex_helper = LexHelper(config=self.config) def test_handler_success(self): \"\"\"Test successful handler execution.\"\"\" # Arrange event = {\"key\": \"value\"} context = Mock() # Act result = self.lex_helper.handler(event, context) # Assert assert result is not None assert \"statusCode\" in result @patch(\"lex_helper.core.handler.some_external_call\") def test_handler_with_mock(self, mock_external): \"\"\"Test handler with mocked external dependencies.\"\"\" # Arrange mock_external.return_value = \"mocked_result\" # Act & Assert # ... test implementation Test Coverage Aim for >90% test coverage Test both success and error paths Include edge cases and boundary conditions Mock external dependencies (AWS services, etc.) CI/CD with GitHub Actions Workflows The project uses GitHub Actions for continuous integration: Main CI Workflow ( .github/workflows/ci.yml ): Runs on push to main/develop branches and pull requests Linting and formatting checks with Ruff Testing across Python 3.12 and 3.13 Package building and artifact storage Automated PyPI releases on version tags Pre-commit Workflow ( .github/workflows/pre-commit.yml ): Additional quality assurance Runs all pre-commit hooks in CI environment Workflow Triggers Push to main/develop : Full CI pipeline Pull requests : Full CI pipeline Version tags ( v* ): Full CI + PyPI release Local Testing Before pushing, ensure your changes pass CI: # Run the same checks as CI uv run ruff check . uv run ruff format --check . uv run pytest --cov=lex_helper uv run pre-commit run --all-files Release Process Version Management Versions are managed in pyproject.toml : [project] version = \"0.0.9\" Testing Releases with TestPyPI Before releasing to production PyPI, you can test releases using TestPyPI: Option 1: Manual TestPyPI Release Go to GitHub Actions \u2192 \"Test Release\" workflow Click \"Run workflow\" Enter a test version (e.g., 0.1.0-test.1 ) The workflow will: Build the package with the test version Publish to TestPyPI Test installation from TestPyPI Option 2: Release Candidate Tags Create a release candidate tag: git tag v0.1.0-rc.1 Push the tag: git push --tags GitHub Actions will automatically publish to TestPyPI Creating a Production Release Update version in pyproject.toml Update CHANGELOG.md with new features and fixes Run full test suite: uv run pytest Run quality checks: uv run pre-commit run --all-files Commit changes: git commit -am \"Release v0.0.9\" Create git tag: git tag v0.0.9 Push changes and tag: git push && git push --tags GitHub Actions will automatically build and release to PyPI Release Types Production releases : Tags like v1.0.0 \u2192 PyPI Release candidates : Tags like v1.0.0-rc.1 \u2192 TestPyPI Manual test releases : Use \"Test Release\" workflow \u2192 TestPyPI PyPI Release Setup The project uses PyPI trusted publishing: - No API tokens required - Configured in PyPI and TestPyPI project settings - Automatic releases based on tag patterns - Secure and maintainable Testing TestPyPI Installations After publishing to TestPyPI, you can test the installation: # Install from TestPyPI pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ lex-helper==0.1.0-test.1 # Test basic functionality python -c \"import lex_helper; print('Import successful')\" Troubleshooting Common Issues Import Errors # Ensure all dependencies are installed uv sync --dev # Check Python path uv run python -c \"import sys; print(sys.path)\" Test Failures # Run tests with verbose output uv run pytest -v -s # Run specific failing test uv run pytest tests/test_handler.py::TestLexHelper::test_specific_method -v Pre-commit Issues # Reinstall hooks uv run pre-commit uninstall uv run pre-commit install # Run with verbose output uv run pre-commit run --verbose --all-files Type Checking Errors # Run pyright with verbose output pyright --verbose # Check specific file pyright lex_helper/core/handler.py Performance Optimization Profiling Tests # Install profiling tools uv add --dev pytest-profiling # Run tests with profiling uv run pytest --profile Memory Usage # Install memory profiling uv add --dev memory-profiler # Profile memory usage uv run python -m memory_profiler your_script.py Contributing Before Submitting Changes Run full test suite: uv run pytest Run code quality checks: uv run pre-commit run --all-files Update documentation if needed Add tests for new functionality Update type hints for new code Code Review Checklist [ ] Tests pass [ ] Code follows style guidelines [ ] Type hints are present and correct [ ] Documentation is updated [ ] No breaking changes (or properly documented) [ ] Performance impact considered Additional Resources uv Documentation Ruff Documentation Pytest Documentation Pydantic Documentation Pre-commit Documentation","title":"Development Guide"},{"location":"DEVELOPMENT/#development-guide","text":"This guide covers common development tasks and workflows for the Lex Helper library.","title":"Development Guide"},{"location":"DEVELOPMENT/#development-environment-setup","text":"","title":"Development Environment Setup"},{"location":"DEVELOPMENT/#initial-setup","text":"# Install uv (Python package manager) pip install uv # Install all dependencies including development tools uv sync --dev # Install pre-commit hooks for automated code quality uv run pre-commit install # Verify setup by running tests uv run pytest","title":"Initial Setup"},{"location":"DEVELOPMENT/#ide-configuration","text":"","title":"IDE Configuration"},{"location":"DEVELOPMENT/#vs-code","text":"Recommended extensions: - Python - Pylance (for type checking) - Ruff (for linting and formatting) Settings for .vscode/settings.json : { \"python.defaultInterpreterPath\": \".venv/bin/python\", \"python.linting.enabled\": false, \"python.formatting.provider\": \"none\", \"[python]\": { \"editor.defaultFormatter\": \"charliermarsh.ruff\", \"editor.codeActionsOnSave\": { \"source.fixAll.ruff\": true, \"source.organizeImports.ruff\": true } }, \"python.analysis.typeCheckingMode\": \"strict\" }","title":"VS Code"},{"location":"DEVELOPMENT/#pycharm","text":"Set Python interpreter to .venv/bin/python Install Ruff plugin Configure Ruff as the default formatter Enable type checking in Python settings","title":"PyCharm"},{"location":"DEVELOPMENT/#common-development-tasks","text":"","title":"Common Development Tasks"},{"location":"DEVELOPMENT/#running-tests","text":"# Run all tests uv run pytest # Run tests with coverage report uv run pytest --cov=lex_helper # Run tests with detailed coverage report uv run pytest --cov=lex_helper --cov-report=html # Run specific test file uv run pytest tests/test_handler.py # Run tests matching a pattern uv run pytest -k \"test_dialog\" # Run tests in verbose mode uv run pytest -v","title":"Running Tests"},{"location":"DEVELOPMENT/#code-quality-checks","text":"# Lint code (check for issues) uv run ruff check . # Lint and auto-fix issues uv run ruff check --fix . # Format code uv run ruff format . # Check specific files uv run ruff check lex_helper/core/handler.py # Show what would be formatted (dry run) uv run ruff format --diff .","title":"Code Quality Checks"},{"location":"DEVELOPMENT/#type-checking","text":"# Run type checking pyright # Type check specific files pyright lex_helper/core/handler.py # Type check with verbose output pyright --verbose","title":"Type Checking"},{"location":"DEVELOPMENT/#pre-commit-hooks","text":"# Run pre-commit on staged files uv run pre-commit run # Run pre-commit on all files uv run pre-commit run --all-files # Run specific hook uv run pre-commit run ruff # Update hook versions uv run pre-commit autoupdate","title":"Pre-commit Hooks"},{"location":"DEVELOPMENT/#dependency-management","text":"# Add new dependency uv add package-name # Add development dependency uv add --dev package-name # Remove dependency uv remove package-name # Update dependencies uv sync # Show dependency tree uv tree # Export requirements (for compatibility) uv export --format requirements-txt > requirements.txt","title":"Dependency Management"},{"location":"DEVELOPMENT/#project-structure","text":"","title":"Project Structure"},{"location":"DEVELOPMENT/#core-components","text":"lex_helper/ \u251c\u2500\u2500 __init__.py # Main exports \u251c\u2500\u2500 core/ # Core functionality \u2502 \u251c\u2500\u2500 handler.py # Main LexHelper class \u2502 \u251c\u2500\u2500 types.py # Pydantic models \u2502 \u251c\u2500\u2500 dialog.py # Dialog utilities \u2502 \u2514\u2500\u2500 ... \u251c\u2500\u2500 channels/ # Channel-specific formatting \u251c\u2500\u2500 formatters/ # Text and response formatters \u251c\u2500\u2500 utils/ # Utility functions \u2514\u2500\u2500 exceptions/ # Custom exceptions","title":"Core Components"},{"location":"DEVELOPMENT/#testing-structure","text":"tests/ \u251c\u2500\u2500 test_handler.py # Handler tests \u251c\u2500\u2500 test_utils.py # Utility tests \u251c\u2500\u2500 test_*.py # Other test files \u2514\u2500\u2500 sample_lex_request.py # Test data","title":"Testing Structure"},{"location":"DEVELOPMENT/#code-style-guidelines","text":"","title":"Code Style Guidelines"},{"location":"DEVELOPMENT/#python-code-style","text":"Line length : 125 characters Quote style : Double quotes for strings Import organization : Automatic with Ruff Type hints : Required for all public APIs Docstrings : Google style for public functions","title":"Python Code Style"},{"location":"DEVELOPMENT/#example-code-style","text":"from typing import Any, Dict, Optional from pydantic import BaseModel, Field from lex_helper.core.types import LexRequest, LexResponse class ExampleModel(BaseModel): \"\"\"Example model with proper type hints and docstrings. Args: name: The name field with validation count: Optional count with default value \"\"\" name: str = Field(..., description=\"Name field\") count: Optional[int] = Field(default=0, description=\"Count field\") def process_data(self, data: Dict[str, Any]) -> Dict[str, Any]: \"\"\"Process the input data and return results. Args: data: Input data dictionary Returns: Processed data dictionary Raises: ValueError: If data is invalid \"\"\" if not data: raise ValueError(\"Data cannot be empty\") return {\"processed\": True, \"original\": data}","title":"Example Code Style"},{"location":"DEVELOPMENT/#testing-guidelines","text":"","title":"Testing Guidelines"},{"location":"DEVELOPMENT/#test-structure","text":"import pytest from unittest.mock import Mock, patch from lex_helper import LexHelper, Config from lex_helper.core.types import LexRequest class TestLexHelper: \"\"\"Test class for LexHelper functionality.\"\"\" def setup_method(self): \"\"\"Set up test fixtures before each test method.\"\"\" self.config = Config() self.lex_helper = LexHelper(config=self.config) def test_handler_success(self): \"\"\"Test successful handler execution.\"\"\" # Arrange event = {\"key\": \"value\"} context = Mock() # Act result = self.lex_helper.handler(event, context) # Assert assert result is not None assert \"statusCode\" in result @patch(\"lex_helper.core.handler.some_external_call\") def test_handler_with_mock(self, mock_external): \"\"\"Test handler with mocked external dependencies.\"\"\" # Arrange mock_external.return_value = \"mocked_result\" # Act & Assert # ... test implementation","title":"Test Structure"},{"location":"DEVELOPMENT/#test-coverage","text":"Aim for >90% test coverage Test both success and error paths Include edge cases and boundary conditions Mock external dependencies (AWS services, etc.)","title":"Test Coverage"},{"location":"DEVELOPMENT/#cicd-with-github-actions","text":"","title":"CI/CD with GitHub Actions"},{"location":"DEVELOPMENT/#workflows","text":"The project uses GitHub Actions for continuous integration: Main CI Workflow ( .github/workflows/ci.yml ): Runs on push to main/develop branches and pull requests Linting and formatting checks with Ruff Testing across Python 3.12 and 3.13 Package building and artifact storage Automated PyPI releases on version tags Pre-commit Workflow ( .github/workflows/pre-commit.yml ): Additional quality assurance Runs all pre-commit hooks in CI environment","title":"Workflows"},{"location":"DEVELOPMENT/#workflow-triggers","text":"Push to main/develop : Full CI pipeline Pull requests : Full CI pipeline Version tags ( v* ): Full CI + PyPI release","title":"Workflow Triggers"},{"location":"DEVELOPMENT/#local-testing","text":"Before pushing, ensure your changes pass CI: # Run the same checks as CI uv run ruff check . uv run ruff format --check . uv run pytest --cov=lex_helper uv run pre-commit run --all-files","title":"Local Testing"},{"location":"DEVELOPMENT/#release-process","text":"","title":"Release Process"},{"location":"DEVELOPMENT/#version-management","text":"Versions are managed in pyproject.toml : [project] version = \"0.0.9\"","title":"Version Management"},{"location":"DEVELOPMENT/#testing-releases-with-testpypi","text":"Before releasing to production PyPI, you can test releases using TestPyPI:","title":"Testing Releases with TestPyPI"},{"location":"DEVELOPMENT/#option-1-manual-testpypi-release","text":"Go to GitHub Actions \u2192 \"Test Release\" workflow Click \"Run workflow\" Enter a test version (e.g., 0.1.0-test.1 ) The workflow will: Build the package with the test version Publish to TestPyPI Test installation from TestPyPI","title":"Option 1: Manual TestPyPI Release"},{"location":"DEVELOPMENT/#option-2-release-candidate-tags","text":"Create a release candidate tag: git tag v0.1.0-rc.1 Push the tag: git push --tags GitHub Actions will automatically publish to TestPyPI","title":"Option 2: Release Candidate Tags"},{"location":"DEVELOPMENT/#creating-a-production-release","text":"Update version in pyproject.toml Update CHANGELOG.md with new features and fixes Run full test suite: uv run pytest Run quality checks: uv run pre-commit run --all-files Commit changes: git commit -am \"Release v0.0.9\" Create git tag: git tag v0.0.9 Push changes and tag: git push && git push --tags GitHub Actions will automatically build and release to PyPI","title":"Creating a Production Release"},{"location":"DEVELOPMENT/#release-types","text":"Production releases : Tags like v1.0.0 \u2192 PyPI Release candidates : Tags like v1.0.0-rc.1 \u2192 TestPyPI Manual test releases : Use \"Test Release\" workflow \u2192 TestPyPI","title":"Release Types"},{"location":"DEVELOPMENT/#pypi-release-setup","text":"The project uses PyPI trusted publishing: - No API tokens required - Configured in PyPI and TestPyPI project settings - Automatic releases based on tag patterns - Secure and maintainable","title":"PyPI Release Setup"},{"location":"DEVELOPMENT/#testing-testpypi-installations","text":"After publishing to TestPyPI, you can test the installation: # Install from TestPyPI pip install --index-url https://test.pypi.org/simple/ --extra-index-url https://pypi.org/simple/ lex-helper==0.1.0-test.1 # Test basic functionality python -c \"import lex_helper; print('Import successful')\"","title":"Testing TestPyPI Installations"},{"location":"DEVELOPMENT/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"DEVELOPMENT/#common-issues","text":"","title":"Common Issues"},{"location":"DEVELOPMENT/#import-errors","text":"# Ensure all dependencies are installed uv sync --dev # Check Python path uv run python -c \"import sys; print(sys.path)\"","title":"Import Errors"},{"location":"DEVELOPMENT/#test-failures","text":"# Run tests with verbose output uv run pytest -v -s # Run specific failing test uv run pytest tests/test_handler.py::TestLexHelper::test_specific_method -v","title":"Test Failures"},{"location":"DEVELOPMENT/#pre-commit-issues","text":"# Reinstall hooks uv run pre-commit uninstall uv run pre-commit install # Run with verbose output uv run pre-commit run --verbose --all-files","title":"Pre-commit Issues"},{"location":"DEVELOPMENT/#type-checking-errors","text":"# Run pyright with verbose output pyright --verbose # Check specific file pyright lex_helper/core/handler.py","title":"Type Checking Errors"},{"location":"DEVELOPMENT/#performance-optimization","text":"","title":"Performance Optimization"},{"location":"DEVELOPMENT/#profiling-tests","text":"# Install profiling tools uv add --dev pytest-profiling # Run tests with profiling uv run pytest --profile","title":"Profiling Tests"},{"location":"DEVELOPMENT/#memory-usage","text":"# Install memory profiling uv add --dev memory-profiler # Profile memory usage uv run python -m memory_profiler your_script.py","title":"Memory Usage"},{"location":"DEVELOPMENT/#contributing","text":"","title":"Contributing"},{"location":"DEVELOPMENT/#before-submitting-changes","text":"Run full test suite: uv run pytest Run code quality checks: uv run pre-commit run --all-files Update documentation if needed Add tests for new functionality Update type hints for new code","title":"Before Submitting Changes"},{"location":"DEVELOPMENT/#code-review-checklist","text":"[ ] Tests pass [ ] Code follows style guidelines [ ] Type hints are present and correct [ ] Documentation is updated [ ] No breaking changes (or properly documented) [ ] Performance impact considered","title":"Code Review Checklist"},{"location":"DEVELOPMENT/#additional-resources","text":"uv Documentation Ruff Documentation Pytest Documentation Pydantic Documentation Pre-commit Documentation","title":"Additional Resources"},{"location":"LAMBDA_LAYER_DEPLOYMENT/","text":"Lambda Layer Deployment Guide for Lex Helper Library Overview This guide covers creating and deploying a Lambda layer containing the lex-helper library and its dependencies. Lambda layers allow you to share code across multiple Lambda functions and reduce deployment package sizes. Prerequisites Python 3.12+ installed locally AWS CLI configured with appropriate permissions lex-helper library (see README.md for installation) Poetry installed (for Method 2): pip install poetry Method 1: Using pip install (Recommended) Step 1: Create Layer Directory Structure mkdir -p lex-helper-layer/python/lib/python3.12/site-packages/ cd lex-helper-layer Step 2: Install lex-helper and Dependencies # Install from PyPI pip install lex-helper -t python/lib/python3.12/site-packages/ # Or install from local source pip install /path/to/lex-helper -t python/lib/python3.12/site-packages/ Step 3: Clean Up Unnecessary Files Remove files that aren't needed in production to reduce layer size: # Remove Python cache files find . -type d -name \"__pycache__\" -exec rm -rf {} + find . -type f -name \"*.pyc\" -delete find . -type f -name \"*.pyo\" -delete # Remove test files and directories find . -type d -name \"tests\" -exec rm -rf {} + find . -type d -name \".pytest_cache\" -exec rm -rf {} + # Remove development files find . -name \"*.egg-info\" -exec rm -rf {} + find . -name \".git*\" -delete find . -name \"*.md\" -delete find . -name \"LICENSE*\" -delete Method 2: Using Poetry Step 1: Create Poetry Project mkdir lex-helper-layer-poetry cd lex-helper-layer-poetry poetry init --no-interaction Step 2: Add lex-helper Dependency # Add lex-helper as dependency poetry add lex-helper # Or add from local source poetry add /path/to/lex-helper Step 3: Export Dependencies and Install to Layer # Export dependencies to requirements.txt poetry export -f requirements.txt --output requirements.txt --without-hashes # Create layer directory mkdir -p ../lex-helper-layer/python/lib/python3.12/site-packages/ # Install dependencies to layer directory pip install -r requirements.txt -t ../lex-helper-layer/python/lib/python3.12/site-packages/ # Clean up cd ../lex-helper-layer Alternative: Using Poetry's Virtual Environment # Create and activate poetry environment poetry install poetry shell # Find the virtual environment path poetry env info --path # Copy site-packages from poetry venv to layer cp -r $(poetry env info --path)/lib/python3.12/site-packages/* python/lib/python3.12/site-packages/ # Remove development dependencies manually rm -rf python/lib/python3.12/site-packages/pytest* rm -rf python/lib/python3.12/site-packages/ruff* Step 4: Clean Up (same as Method 1, Step 3) Verify Layer Contents and Size Check Layer Size Lambda layers have a 250 MB unzipped size limit: du -sh lex-helper-layer/ # Expected output: ~10-15MB for lex-helper with dependencies View Layer Contents find lex-helper-layer -type f | head -20 Expected structure: lex-helper-layer/ \u2514\u2500\u2500 python/ \u2514\u2500\u2500 lib/ \u2514\u2500\u2500 python3.12/ \u2514\u2500\u2500 site-packages/ \u251c\u2500\u2500 lex_helper/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 core/ \u2502 \u2514\u2500\u2500 utils/ \u2514\u2500\u2500 pydantic/ Package the Layer Create ZIP Archive cd lex-helper-layer zip -r ../lex-helper-layer.zip . cd .. Verify ZIP Contents unzip -l lex-helper-layer.zip | head -10 Deploy to AWS Lambda Using AWS CLI # Create new layer version aws lambda publish-layer-version \\ --layer-name lex-helper-layer \\ --description \"Lex Helper Library with dependencies\" \\ --zip-file fileb://lex-helper-layer.zip \\ --compatible-runtimes python3.12 \\ --compatible-architectures x86_64 arm64 # Note the LayerVersionArn from the response Using AWS Console Open AWS Lambda Console Navigate to \"Layers\" in the left sidebar Click \"Create layer\" Fill in: Name: lex-helper-layer Description: Lex Helper Library with dependencies Upload ZIP file: lex-helper-layer.zip Compatible runtimes: Python 3.12 Compatible architectures: x86_64 , arm64 Click \"Create\" Using the Layer in Lambda Functions Add Layer to Function (AWS CLI) aws lambda update-function-configuration \\ --function-name your-lex-bot-function \\ --layers arn:aws:lambda:region:account:layer:lex-helper-layer:1 Add Layer to Function (Console) Open your Lambda function Scroll to \"Layers\" section Click \"Add a layer\" Select \"Custom layers\" Choose your lex-helper-layer Select the latest version Click \"Add\" Using in Your Lambda Code Once the layer is attached, import normally: from lex_helper import Config, LexHelper, dialog, LexPlainText from lex_helper.core.types import LexRequest, LexResponse def lambda_handler(event, context): # Your code here pass Environment Variables Configure these environment variables in your Lambda function: # Optional: Custom messages file path MESSAGES_YAML_PATH=/opt/lambda/config/ # AWS region for Bedrock and other services AWS_REGION=us-east-1 # Logging level LOG_LEVEL=INFO Automation with Infrastructure as Code CloudFormation Template AWSTemplateFormatVersion: '2010-09-09' Resources: LexHelperLayer: Type: AWS::Lambda::LayerVersion Properties: LayerName: lex-helper-layer Description: Lex Helper Library with dependencies Content: S3Bucket: your-deployment-bucket S3Key: layers/lex-helper-layer.zip CompatibleRuntimes: - python3.12 CompatibleArchitectures: - x86_64 - arm64 YourLexBotFunction: Type: AWS::Lambda::Function Properties: FunctionName: your-lex-bot-function Runtime: python3.12 Handler: handler.lambda_handler Code: S3Bucket: your-deployment-bucket S3Key: functions/your-bot.zip Layers: - !Ref LexHelperLayer Environment: Variables: MESSAGES_YAML_PATH: /opt/lambda/config/ AWS_REGION: us-east-1 LOG_LEVEL: INFO Terraform Configuration resource \"aws_lambda_layer_version\" \"lex_helper\" { filename = \"lex-helper-layer.zip\" layer_name = \"lex-helper-layer\" description = \"Lex Helper Library with dependencies\" compatible_runtimes = [\"python3.12\"] compatible_architectures = [\"x86_64\", \"arm64\"] } resource \"aws_lambda_function\" \"lex_bot\" { filename = \"your-bot.zip\" function_name = \"your-lex-bot-function\" role = aws_iam_role.lambda_role.arn handler = \"handler.lambda_handler\" runtime = \"python3.12\" layers = [aws_lambda_layer_version.lex_helper.arn] environment { variables = { MESSAGES_YAML_PATH = \"/opt/lambda/config/\" AWS_REGION = \"us-east-1\" LOG_LEVEL = \"INFO\" } } } Best Practices Layer Management Version Control : Tag layer versions for easy rollback Size Optimization : Regularly clean up unused dependencies Regional Deployment : Deploy layers in all regions where functions run Permissions : Set appropriate layer permissions for sharing Development Workflow Local Testing : Test with the same layer structure locally CI/CD Integration : Automate layer building and deployment Dependency Updates : Monitor for security updates in dependencies Troubleshooting Common Issues Import Errors : # Verify layer is attached and imports work import sys print(sys.path) # Should include /opt/python/lib/python3.12/site-packages Size Limits : - Unzipped layer size: 250 MB maximum - Total function + layers: 250 MB unzipped - Deployment package: 50 MB zipped (direct upload) Python Version Mismatch : - Ensure layer Python version matches Lambda runtime - Use correct site-packages path for Python version Verification Script # Add to your Lambda function for debugging def verify_layer(): try: import lex_helper print(f\"lex-helper version: {lex_helper.__version__}\") print(f\"lex-helper location: {lex_helper.__file__}\") return True except ImportError as e: print(f\"Import error: {e}\") return False # Call in lambda_handler for testing verify_layer() Layer Updates Updating the Layer Modify dependencies or add new packages Rebuild the layer following steps above Create new layer version Update Lambda functions to use new version Test thoroughly before removing old versions Rollback Strategy # List layer versions aws lambda list-layer-versions --layer-name lex-helper-layer # Rollback function to previous layer version aws lambda update-function-configuration \\ --function-name your-lex-bot-function \\ --layers arn:aws:lambda:region:account:layer:lex-helper-layer:PREVIOUS_VERSION This approach provides a clean, maintainable way to deploy and manage the lex-helper library across your Lambda functions.","title":"Lambda Layer Deployment Guide for Lex Helper Library"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#lambda-layer-deployment-guide-for-lex-helper-library","text":"","title":"Lambda Layer Deployment Guide for Lex Helper Library"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#overview","text":"This guide covers creating and deploying a Lambda layer containing the lex-helper library and its dependencies. Lambda layers allow you to share code across multiple Lambda functions and reduce deployment package sizes.","title":"Overview"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#prerequisites","text":"Python 3.12+ installed locally AWS CLI configured with appropriate permissions lex-helper library (see README.md for installation) Poetry installed (for Method 2): pip install poetry","title":"Prerequisites"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#method-1-using-pip-install-recommended","text":"","title":"Method 1: Using pip install (Recommended)"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#step-1-create-layer-directory-structure","text":"mkdir -p lex-helper-layer/python/lib/python3.12/site-packages/ cd lex-helper-layer","title":"Step 1: Create Layer Directory Structure"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#step-2-install-lex-helper-and-dependencies","text":"# Install from PyPI pip install lex-helper -t python/lib/python3.12/site-packages/ # Or install from local source pip install /path/to/lex-helper -t python/lib/python3.12/site-packages/","title":"Step 2: Install lex-helper and Dependencies"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#step-3-clean-up-unnecessary-files","text":"Remove files that aren't needed in production to reduce layer size: # Remove Python cache files find . -type d -name \"__pycache__\" -exec rm -rf {} + find . -type f -name \"*.pyc\" -delete find . -type f -name \"*.pyo\" -delete # Remove test files and directories find . -type d -name \"tests\" -exec rm -rf {} + find . -type d -name \".pytest_cache\" -exec rm -rf {} + # Remove development files find . -name \"*.egg-info\" -exec rm -rf {} + find . -name \".git*\" -delete find . -name \"*.md\" -delete find . -name \"LICENSE*\" -delete","title":"Step 3: Clean Up Unnecessary Files"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#method-2-using-poetry","text":"","title":"Method 2: Using Poetry"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#step-1-create-poetry-project","text":"mkdir lex-helper-layer-poetry cd lex-helper-layer-poetry poetry init --no-interaction","title":"Step 1: Create Poetry Project"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#step-2-add-lex-helper-dependency","text":"# Add lex-helper as dependency poetry add lex-helper # Or add from local source poetry add /path/to/lex-helper","title":"Step 2: Add lex-helper Dependency"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#step-3-export-dependencies-and-install-to-layer","text":"# Export dependencies to requirements.txt poetry export -f requirements.txt --output requirements.txt --without-hashes # Create layer directory mkdir -p ../lex-helper-layer/python/lib/python3.12/site-packages/ # Install dependencies to layer directory pip install -r requirements.txt -t ../lex-helper-layer/python/lib/python3.12/site-packages/ # Clean up cd ../lex-helper-layer","title":"Step 3: Export Dependencies and Install to Layer"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#alternative-using-poetrys-virtual-environment","text":"# Create and activate poetry environment poetry install poetry shell # Find the virtual environment path poetry env info --path # Copy site-packages from poetry venv to layer cp -r $(poetry env info --path)/lib/python3.12/site-packages/* python/lib/python3.12/site-packages/ # Remove development dependencies manually rm -rf python/lib/python3.12/site-packages/pytest* rm -rf python/lib/python3.12/site-packages/ruff*","title":"Alternative: Using Poetry's Virtual Environment"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#step-4-clean-up-same-as-method-1-step-3","text":"","title":"Step 4: Clean Up (same as Method 1, Step 3)"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#verify-layer-contents-and-size","text":"","title":"Verify Layer Contents and Size"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#check-layer-size","text":"Lambda layers have a 250 MB unzipped size limit: du -sh lex-helper-layer/ # Expected output: ~10-15MB for lex-helper with dependencies","title":"Check Layer Size"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#view-layer-contents","text":"find lex-helper-layer -type f | head -20 Expected structure: lex-helper-layer/ \u2514\u2500\u2500 python/ \u2514\u2500\u2500 lib/ \u2514\u2500\u2500 python3.12/ \u2514\u2500\u2500 site-packages/ \u251c\u2500\u2500 lex_helper/ \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u251c\u2500\u2500 core/ \u2502 \u2514\u2500\u2500 utils/ \u2514\u2500\u2500 pydantic/","title":"View Layer Contents"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#package-the-layer","text":"","title":"Package the Layer"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#create-zip-archive","text":"cd lex-helper-layer zip -r ../lex-helper-layer.zip . cd ..","title":"Create ZIP Archive"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#verify-zip-contents","text":"unzip -l lex-helper-layer.zip | head -10","title":"Verify ZIP Contents"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#deploy-to-aws-lambda","text":"","title":"Deploy to AWS Lambda"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#using-aws-cli","text":"# Create new layer version aws lambda publish-layer-version \\ --layer-name lex-helper-layer \\ --description \"Lex Helper Library with dependencies\" \\ --zip-file fileb://lex-helper-layer.zip \\ --compatible-runtimes python3.12 \\ --compatible-architectures x86_64 arm64 # Note the LayerVersionArn from the response","title":"Using AWS CLI"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#using-aws-console","text":"Open AWS Lambda Console Navigate to \"Layers\" in the left sidebar Click \"Create layer\" Fill in: Name: lex-helper-layer Description: Lex Helper Library with dependencies Upload ZIP file: lex-helper-layer.zip Compatible runtimes: Python 3.12 Compatible architectures: x86_64 , arm64 Click \"Create\"","title":"Using AWS Console"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#using-the-layer-in-lambda-functions","text":"","title":"Using the Layer in Lambda Functions"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#add-layer-to-function-aws-cli","text":"aws lambda update-function-configuration \\ --function-name your-lex-bot-function \\ --layers arn:aws:lambda:region:account:layer:lex-helper-layer:1","title":"Add Layer to Function (AWS CLI)"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#add-layer-to-function-console","text":"Open your Lambda function Scroll to \"Layers\" section Click \"Add a layer\" Select \"Custom layers\" Choose your lex-helper-layer Select the latest version Click \"Add\"","title":"Add Layer to Function (Console)"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#using-in-your-lambda-code","text":"Once the layer is attached, import normally: from lex_helper import Config, LexHelper, dialog, LexPlainText from lex_helper.core.types import LexRequest, LexResponse def lambda_handler(event, context): # Your code here pass","title":"Using in Your Lambda Code"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#environment-variables","text":"Configure these environment variables in your Lambda function: # Optional: Custom messages file path MESSAGES_YAML_PATH=/opt/lambda/config/ # AWS region for Bedrock and other services AWS_REGION=us-east-1 # Logging level LOG_LEVEL=INFO","title":"Environment Variables"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#automation-with-infrastructure-as-code","text":"","title":"Automation with Infrastructure as Code"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#cloudformation-template","text":"AWSTemplateFormatVersion: '2010-09-09' Resources: LexHelperLayer: Type: AWS::Lambda::LayerVersion Properties: LayerName: lex-helper-layer Description: Lex Helper Library with dependencies Content: S3Bucket: your-deployment-bucket S3Key: layers/lex-helper-layer.zip CompatibleRuntimes: - python3.12 CompatibleArchitectures: - x86_64 - arm64 YourLexBotFunction: Type: AWS::Lambda::Function Properties: FunctionName: your-lex-bot-function Runtime: python3.12 Handler: handler.lambda_handler Code: S3Bucket: your-deployment-bucket S3Key: functions/your-bot.zip Layers: - !Ref LexHelperLayer Environment: Variables: MESSAGES_YAML_PATH: /opt/lambda/config/ AWS_REGION: us-east-1 LOG_LEVEL: INFO","title":"CloudFormation Template"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#terraform-configuration","text":"resource \"aws_lambda_layer_version\" \"lex_helper\" { filename = \"lex-helper-layer.zip\" layer_name = \"lex-helper-layer\" description = \"Lex Helper Library with dependencies\" compatible_runtimes = [\"python3.12\"] compatible_architectures = [\"x86_64\", \"arm64\"] } resource \"aws_lambda_function\" \"lex_bot\" { filename = \"your-bot.zip\" function_name = \"your-lex-bot-function\" role = aws_iam_role.lambda_role.arn handler = \"handler.lambda_handler\" runtime = \"python3.12\" layers = [aws_lambda_layer_version.lex_helper.arn] environment { variables = { MESSAGES_YAML_PATH = \"/opt/lambda/config/\" AWS_REGION = \"us-east-1\" LOG_LEVEL = \"INFO\" } } }","title":"Terraform Configuration"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#best-practices","text":"","title":"Best Practices"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#layer-management","text":"Version Control : Tag layer versions for easy rollback Size Optimization : Regularly clean up unused dependencies Regional Deployment : Deploy layers in all regions where functions run Permissions : Set appropriate layer permissions for sharing","title":"Layer Management"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#development-workflow","text":"Local Testing : Test with the same layer structure locally CI/CD Integration : Automate layer building and deployment Dependency Updates : Monitor for security updates in dependencies","title":"Development Workflow"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#common-issues","text":"Import Errors : # Verify layer is attached and imports work import sys print(sys.path) # Should include /opt/python/lib/python3.12/site-packages Size Limits : - Unzipped layer size: 250 MB maximum - Total function + layers: 250 MB unzipped - Deployment package: 50 MB zipped (direct upload) Python Version Mismatch : - Ensure layer Python version matches Lambda runtime - Use correct site-packages path for Python version","title":"Common Issues"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#verification-script","text":"# Add to your Lambda function for debugging def verify_layer(): try: import lex_helper print(f\"lex-helper version: {lex_helper.__version__}\") print(f\"lex-helper location: {lex_helper.__file__}\") return True except ImportError as e: print(f\"Import error: {e}\") return False # Call in lambda_handler for testing verify_layer()","title":"Verification Script"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#layer-updates","text":"","title":"Layer Updates"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#updating-the-layer","text":"Modify dependencies or add new packages Rebuild the layer following steps above Create new layer version Update Lambda functions to use new version Test thoroughly before removing old versions","title":"Updating the Layer"},{"location":"LAMBDA_LAYER_DEPLOYMENT/#rollback-strategy","text":"# List layer versions aws lambda list-layer-versions --layer-name lex-helper-layer # Rollback function to previous layer version aws lambda update-function-configuration \\ --function-name your-lex-bot-function \\ --layers arn:aws:lambda:region:account:layer:lex-helper-layer:PREVIOUS_VERSION This approach provides a clean, maintainable way to deploy and manage the lex-helper library across your Lambda functions.","title":"Rollback Strategy"},{"location":"SECURITY/","text":"Reporting Security Issues We take all security reports seriously. When we receive such reports, we will investigate and subsequently address any potential vulnerabilities as quickly as possible. If you discover a potential security issue in this project, please notify AWS/Amazon Security via our vulnerability reporting page or directly via email to AWS Security . Please do not create a public GitHub issue in this project.","title":"SECURITY"},{"location":"SECURITY/#reporting-security-issues","text":"We take all security reports seriously. When we receive such reports, we will investigate and subsequently address any potential vulnerabilities as quickly as possible. If you discover a potential security issue in this project, please notify AWS/Amazon Security via our vulnerability reporting page or directly via email to AWS Security . Please do not create a public GitHub issue in this project.","title":"Reporting Security Issues"},{"location":"SUPPORT/","text":"Support For support information, please see the Support section in our README . Getting Help For Issues Check existing GitHub Issues Create a new issue with detailed information about your problem Include Python version, library version, and error messages For Development Questions Review the Contributing Guide Check the development setup instructions in the README","title":"Support"},{"location":"SUPPORT/#support","text":"For support information, please see the Support section in our README .","title":"Support"},{"location":"SUPPORT/#getting-help","text":"","title":"Getting Help"},{"location":"SUPPORT/#for-issues","text":"Check existing GitHub Issues Create a new issue with detailed information about your problem Include Python version, library version, and error messages","title":"For Issues"},{"location":"SUPPORT/#for-development-questions","text":"Review the Contributing Guide Check the development setup instructions in the README","title":"For Development Questions"},{"location":"TESTING_GUIDE/","text":"Testing Guide for Lex Helper Library This guide covers comprehensive testing strategies for Lex bots built with the Lex Helper library. For basic setup and usage, see README.md and BEST_PRACTICES.md . Test Helper Functions import pytest from lex_helper import dialog, LexPlainText, set_locale, get_message, MessageManager from your_project.intents.booking_intent import handle_booking_intent from your_project.session_attributes import CustomSessionAttributes def create_test_request(intent_name=\"BookingIntent\", slots=None, session_attrs=None): \"\"\"Helper to create test requests\"\"\" return { \"sessionId\": \"test-session\", \"inputTranscript\": \"test input\", \"sessionState\": { \"sessionAttributes\": session_attrs or {}, \"activeContexts\": [], \"intent\": { \"name\": intent_name, \"slots\": slots or {}, \"state\": \"InProgress\", \"confirmationState\": \"None\", }, }, } Unit Testing Slot Elicitation Test that your intent handlers properly elicit required slots: def test_elicit_missing_slot(): \"\"\"Test that missing slots are properly elicited\"\"\" # Create request without required slot request_dict = create_test_request(slots={}) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response = handle_booking_intent(lex_request) # Verify slot elicitation assert response.sessionState.dialogAction.type == \"ElicitSlot\" assert response.sessionState.dialogAction.slotToElicit == \"destination\" assert len(response.messages) > 0 assert isinstance(response.messages[0], LexPlainText) def test_slot_validation(): \"\"\"Test slot value validation\"\"\" # Create request with invalid slot value slots = {\"email\": {\"value\": {\"originalValue\": \"invalid-email\"}}} request_dict = create_test_request(slots=slots) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response = handle_booking_intent(lex_request) # Should re-elicit the slot assert response.sessionState.dialogAction.type == \"ElicitSlot\" assert response.sessionState.dialogAction.slotToElicit == \"email\" def test_all_slots_filled(): \"\"\"Test behavior when all required slots are filled\"\"\" slots = { \"destination\": {\"value\": {\"originalValue\": \"Paris\"}}, \"date\": {\"value\": {\"originalValue\": \"2024-01-15\"}}, \"email\": {\"value\": {\"originalValue\": \"user@example.com\"}} } request_dict = create_test_request(slots=slots) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response = handle_booking_intent(lex_request) # Should delegate or close assert response.sessionState.dialogAction.type in [\"Delegate\", \"Close\"] ### Testing Dialog Flow Transitions Validate multi-turn conversations and intent transitions: ```python def test_intent_transition(): \"\"\"Test transitioning between intents\"\"\" request_dict = create_test_request() lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) # Simulate transition to authentication response = dialog.transition_to_intent( intent_name=\"authenticate\", lex_request=lex_request, messages=[LexPlainText(content=\"Please authenticate\")] ) assert response.sessionState.intent.name == \"authenticate\" assert len(response.messages) > 0 assert response.messages[0].content == \"Please authenticate\" def test_callback_pattern(): \"\"\"Test callback pattern for returning to original intent\"\"\" # Set up callback request_dict = create_test_request() lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) lex_request.sessionState.sessionAttributes.callback_handler = \"BookingIntent\" lex_request.sessionState.sessionAttributes.callback_event = json.dumps(lex_request, default=str) # Test callback handler response = dialog.callback_original_intent_handler(lex_request) assert response is not None # Verify session attributes were merged properly Testing Unknown Choice Handling Validate error handling for invalid user inputs: def test_unknown_slot_choice_detection(): \"\"\"Test detection of unknown slot choices\"\"\" # Set up previous elicit slot state session_attrs = { \"previous_dialog_action_type\": \"ElicitSlot\", \"previous_slot_to_elicit\": \"BookingIntentSlot.DESTINATION\" } request_dict = create_test_request( slots={}, # No slot filled (unknown choice) session_attrs=session_attrs ) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) # Should detect unknown choice assert dialog.any_unknown_slot_choices(lex_request) == True def test_valid_slot_choice(): \"\"\"Test that valid choices are not flagged as unknown\"\"\" session_attrs = { \"previous_dialog_action_type\": \"ElicitSlot\", \"previous_slot_to_elicit\": \"BookingIntentSlot.DESTINATION\" } slots = {\"destination\": {\"value\": {\"originalValue\": \"Paris\"}}} request_dict = create_test_request(slots=slots, session_attrs=session_attrs) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) # Should not detect unknown choice assert dialog.any_unknown_slot_choices(lex_request) == False def test_error_count_increment(): \"\"\"Test that error count increments on unknown choices\"\"\" session_attrs = { \"previous_dialog_action_type\": \"ElicitSlot\", \"previous_slot_to_elicit\": \"BookingIntentSlot.DESTINATION\", \"error_count\": 1 } request_dict = create_test_request(slots={}, session_attrs=session_attrs) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) dialog.any_unknown_slot_choices(lex_request) # Error count should increment assert lex_request.sessionState.sessionAttributes.error_count == 2 Integration Testing Test complete dialog flows end-to-end: def test_complete_booking_flow(): \"\"\"Test complete booking conversation flow\"\"\" # Step 1: Initial request request_dict = create_test_request() lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response1 = handle_booking_intent(lex_request) assert response1.sessionState.dialogAction.type == \"ElicitSlot\" # Step 2: Provide destination slots = {\"destination\": {\"value\": {\"originalValue\": \"Paris\"}}} request_dict = create_test_request(slots=slots) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response2 = handle_booking_intent(lex_request) # Should elicit next slot (date) assert response2.sessionState.dialogAction.slotToElicit == \"date\" # Step 3: Complete all slots slots = { \"destination\": {\"value\": {\"originalValue\": \"Paris\"}}, \"date\": {\"value\": {\"originalValue\": \"2024-01-15\"}}, \"email\": {\"value\": {\"originalValue\": \"user@example.com\"}} } request_dict = create_test_request(slots=slots) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response3 = handle_booking_intent(lex_request) assert response3.sessionState.dialogAction.type in [\"Delegate\", \"Close\"] Testing Session Attributes Validate session state management: def test_session_attribute_persistence(): \"\"\"Test that session attributes persist across turns\"\"\" session_attrs = {\"user_name\": \"John\", \"visit_count\": 1} request_dict = create_test_request(session_attrs=session_attrs) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) # Modify session attributes lex_request.sessionState.sessionAttributes.visit_count += 1 response = handle_booking_intent(lex_request) # Verify attributes are maintained assert response.sessionState.sessionAttributes.user_name == \"John\" assert response.sessionState.sessionAttributes.visit_count == 2 def test_session_attribute_merging(): \"\"\"Test session attribute merging in callback scenarios\"\"\" # Create original request with callback data original_attrs = {\"user_name\": \"John\", \"booking_id\": \"123\"} callback_event = json.dumps(create_test_request(session_attrs=original_attrs), default=str) # Create current request with additional attributes current_attrs = { \"callback_event\": callback_event, \"callback_handler\": \"BookingIntent\", \"auth_token\": \"abc123\" } request_dict = create_test_request(session_attrs=current_attrs) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response = dialog.callback_original_intent_handler(lex_request) # Both original and current attributes should be present assert hasattr(response.sessionState.sessionAttributes, 'user_name') assert hasattr(response.sessionState.sessionAttributes, 'auth_token') Testing Message Handling Validate message creation and formatting: def test_message_loading(): \"\"\"Test loading messages from JSON\"\"\" messages_json = '''[ {\"contentType\": \"PlainText\", \"content\": \"Hello!\"}, {\"contentType\": \"ImageResponseCard\", \"imageResponseCard\": {\"title\": \"Test\"}} ]''' messages = dialog.load_messages(messages_json) assert len(messages) == 2 assert isinstance(messages[0], LexPlainText) assert messages[0].content == \"Hello!\" def test_message_prepending(): \"\"\"Test that messages are properly prepended in transitions\"\"\" request_dict = create_test_request() lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) input_messages = [LexPlainText(content=\"Transition message\")] # Mock the handler to return a response with messages def mock_handler(intent_name, lex_request): return dialog.LexResponse( sessionState=lex_request.sessionState, messages=[LexPlainText(content=\"Handler message\")], requestAttributes={} ) # Test message prepending response = dialog.transition_to_intent( intent_name=\"test_intent\", lex_request=lex_request, messages=input_messages ) # Input messages should come first assert len(response.messages) >= 1 assert response.messages[0].content == \"Transition message\" Testing Message Management Test localized messages and MessageManager functionality: def test_message_loading(): \"\"\"Test loading messages for different locales\"\"\" # Test English messages set_locale(\"en_US\") greeting = get_message(\"greeting\") assert \"Hello\" in greeting # Test Spanish messages set_locale(\"es_ES\") spanish_greeting = get_message(\"greeting\") assert \"Hola\" in spanish_greeting # Test fallback to default fallback_message = get_message(\"nonexistent.key\", \"Default message\") assert fallback_message == \"Default message\" def test_locale_override(): \"\"\"Test locale override in get_message\"\"\" set_locale(\"en_US\") # Get message in current locale english_msg = get_message(\"greeting\") # Override locale for specific message spanish_msg = get_message(\"greeting\", locale=\"es_ES\") assert english_msg != spanish_msg assert \"Hello\" in english_msg assert \"Hola\" in spanish_msg def test_message_manager_singleton(): \"\"\"Test MessageManager singleton behavior\"\"\" manager1 = MessageManager() manager2 = MessageManager() assert manager1 is manager2 # Test that locale changes affect all instances manager1.set_locale(\"fr_FR\") french_msg = manager2.get_message(\"greeting\") assert \"Bonjour\" in french_msg or \"greeting\" in french_msg # fallback def test_nested_message_keys(): \"\"\"Test nested message key access\"\"\" set_locale(\"en_US\") # Test nested key access agent_confirmation = get_message(\"agent.confirmation\") error_general = get_message(\"error.general\") assert agent_confirmation != \"Message not found: agent.confirmation\" assert error_general != \"Message not found: error.general\" Running Tests Use pytest to run your tests: # Run all tests pytest tests/ # Run specific test file pytest tests/test_dialog_flows.py # Run with coverage pytest --cov=your_project tests/ # Run tests with verbose output pytest -v tests/ Test Organization Structure your tests to match your intent organization: tests/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 conftest.py # Shared fixtures \u251c\u2500\u2500 test_dialog_flows.py # Dialog flow tests \u251c\u2500\u2500 test_slot_validation.py # Slot validation tests \u251c\u2500\u2500 test_session_management.py # Session attribute tests \u2514\u2500\u2500 intents/ \u251c\u2500\u2500 test_booking_intent.py \u251c\u2500\u2500 test_welcome_intent.py \u2514\u2500\u2500 test_fallback_intent.py Best Practices for Testing Use fixtures for common test data and setup Test edge cases like empty inputs, invalid data, and error conditions Mock external dependencies to isolate your bot logic Test across channels by simulating different request attributes Validate error handling and fallback behaviors Test session state persistence and transitions Use descriptive test names that explain the scenario being tested This comprehensive testing approach ensures your Lex bot handles all dialog scenarios correctly and provides a reliable user experience.","title":"Testing Guide for Lex Helper Library"},{"location":"TESTING_GUIDE/#testing-guide-for-lex-helper-library","text":"This guide covers comprehensive testing strategies for Lex bots built with the Lex Helper library. For basic setup and usage, see README.md and BEST_PRACTICES.md .","title":"Testing Guide for Lex Helper Library"},{"location":"TESTING_GUIDE/#test-helper-functions","text":"import pytest from lex_helper import dialog, LexPlainText, set_locale, get_message, MessageManager from your_project.intents.booking_intent import handle_booking_intent from your_project.session_attributes import CustomSessionAttributes def create_test_request(intent_name=\"BookingIntent\", slots=None, session_attrs=None): \"\"\"Helper to create test requests\"\"\" return { \"sessionId\": \"test-session\", \"inputTranscript\": \"test input\", \"sessionState\": { \"sessionAttributes\": session_attrs or {}, \"activeContexts\": [], \"intent\": { \"name\": intent_name, \"slots\": slots or {}, \"state\": \"InProgress\", \"confirmationState\": \"None\", }, }, }","title":"Test Helper Functions"},{"location":"TESTING_GUIDE/#unit-testing-slot-elicitation","text":"Test that your intent handlers properly elicit required slots: def test_elicit_missing_slot(): \"\"\"Test that missing slots are properly elicited\"\"\" # Create request without required slot request_dict = create_test_request(slots={}) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response = handle_booking_intent(lex_request) # Verify slot elicitation assert response.sessionState.dialogAction.type == \"ElicitSlot\" assert response.sessionState.dialogAction.slotToElicit == \"destination\" assert len(response.messages) > 0 assert isinstance(response.messages[0], LexPlainText) def test_slot_validation(): \"\"\"Test slot value validation\"\"\" # Create request with invalid slot value slots = {\"email\": {\"value\": {\"originalValue\": \"invalid-email\"}}} request_dict = create_test_request(slots=slots) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response = handle_booking_intent(lex_request) # Should re-elicit the slot assert response.sessionState.dialogAction.type == \"ElicitSlot\" assert response.sessionState.dialogAction.slotToElicit == \"email\" def test_all_slots_filled(): \"\"\"Test behavior when all required slots are filled\"\"\" slots = { \"destination\": {\"value\": {\"originalValue\": \"Paris\"}}, \"date\": {\"value\": {\"originalValue\": \"2024-01-15\"}}, \"email\": {\"value\": {\"originalValue\": \"user@example.com\"}} } request_dict = create_test_request(slots=slots) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response = handle_booking_intent(lex_request) # Should delegate or close assert response.sessionState.dialogAction.type in [\"Delegate\", \"Close\"] ### Testing Dialog Flow Transitions Validate multi-turn conversations and intent transitions: ```python def test_intent_transition(): \"\"\"Test transitioning between intents\"\"\" request_dict = create_test_request() lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) # Simulate transition to authentication response = dialog.transition_to_intent( intent_name=\"authenticate\", lex_request=lex_request, messages=[LexPlainText(content=\"Please authenticate\")] ) assert response.sessionState.intent.name == \"authenticate\" assert len(response.messages) > 0 assert response.messages[0].content == \"Please authenticate\" def test_callback_pattern(): \"\"\"Test callback pattern for returning to original intent\"\"\" # Set up callback request_dict = create_test_request() lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) lex_request.sessionState.sessionAttributes.callback_handler = \"BookingIntent\" lex_request.sessionState.sessionAttributes.callback_event = json.dumps(lex_request, default=str) # Test callback handler response = dialog.callback_original_intent_handler(lex_request) assert response is not None # Verify session attributes were merged properly","title":"Unit Testing Slot Elicitation"},{"location":"TESTING_GUIDE/#testing-unknown-choice-handling","text":"Validate error handling for invalid user inputs: def test_unknown_slot_choice_detection(): \"\"\"Test detection of unknown slot choices\"\"\" # Set up previous elicit slot state session_attrs = { \"previous_dialog_action_type\": \"ElicitSlot\", \"previous_slot_to_elicit\": \"BookingIntentSlot.DESTINATION\" } request_dict = create_test_request( slots={}, # No slot filled (unknown choice) session_attrs=session_attrs ) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) # Should detect unknown choice assert dialog.any_unknown_slot_choices(lex_request) == True def test_valid_slot_choice(): \"\"\"Test that valid choices are not flagged as unknown\"\"\" session_attrs = { \"previous_dialog_action_type\": \"ElicitSlot\", \"previous_slot_to_elicit\": \"BookingIntentSlot.DESTINATION\" } slots = {\"destination\": {\"value\": {\"originalValue\": \"Paris\"}}} request_dict = create_test_request(slots=slots, session_attrs=session_attrs) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) # Should not detect unknown choice assert dialog.any_unknown_slot_choices(lex_request) == False def test_error_count_increment(): \"\"\"Test that error count increments on unknown choices\"\"\" session_attrs = { \"previous_dialog_action_type\": \"ElicitSlot\", \"previous_slot_to_elicit\": \"BookingIntentSlot.DESTINATION\", \"error_count\": 1 } request_dict = create_test_request(slots={}, session_attrs=session_attrs) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) dialog.any_unknown_slot_choices(lex_request) # Error count should increment assert lex_request.sessionState.sessionAttributes.error_count == 2","title":"Testing Unknown Choice Handling"},{"location":"TESTING_GUIDE/#integration-testing","text":"Test complete dialog flows end-to-end: def test_complete_booking_flow(): \"\"\"Test complete booking conversation flow\"\"\" # Step 1: Initial request request_dict = create_test_request() lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response1 = handle_booking_intent(lex_request) assert response1.sessionState.dialogAction.type == \"ElicitSlot\" # Step 2: Provide destination slots = {\"destination\": {\"value\": {\"originalValue\": \"Paris\"}}} request_dict = create_test_request(slots=slots) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response2 = handle_booking_intent(lex_request) # Should elicit next slot (date) assert response2.sessionState.dialogAction.slotToElicit == \"date\" # Step 3: Complete all slots slots = { \"destination\": {\"value\": {\"originalValue\": \"Paris\"}}, \"date\": {\"value\": {\"originalValue\": \"2024-01-15\"}}, \"email\": {\"value\": {\"originalValue\": \"user@example.com\"}} } request_dict = create_test_request(slots=slots) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response3 = handle_booking_intent(lex_request) assert response3.sessionState.dialogAction.type in [\"Delegate\", \"Close\"]","title":"Integration Testing"},{"location":"TESTING_GUIDE/#testing-session-attributes","text":"Validate session state management: def test_session_attribute_persistence(): \"\"\"Test that session attributes persist across turns\"\"\" session_attrs = {\"user_name\": \"John\", \"visit_count\": 1} request_dict = create_test_request(session_attrs=session_attrs) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) # Modify session attributes lex_request.sessionState.sessionAttributes.visit_count += 1 response = handle_booking_intent(lex_request) # Verify attributes are maintained assert response.sessionState.sessionAttributes.user_name == \"John\" assert response.sessionState.sessionAttributes.visit_count == 2 def test_session_attribute_merging(): \"\"\"Test session attribute merging in callback scenarios\"\"\" # Create original request with callback data original_attrs = {\"user_name\": \"John\", \"booking_id\": \"123\"} callback_event = json.dumps(create_test_request(session_attrs=original_attrs), default=str) # Create current request with additional attributes current_attrs = { \"callback_event\": callback_event, \"callback_handler\": \"BookingIntent\", \"auth_token\": \"abc123\" } request_dict = create_test_request(session_attrs=current_attrs) lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) response = dialog.callback_original_intent_handler(lex_request) # Both original and current attributes should be present assert hasattr(response.sessionState.sessionAttributes, 'user_name') assert hasattr(response.sessionState.sessionAttributes, 'auth_token')","title":"Testing Session Attributes"},{"location":"TESTING_GUIDE/#testing-message-handling","text":"Validate message creation and formatting: def test_message_loading(): \"\"\"Test loading messages from JSON\"\"\" messages_json = '''[ {\"contentType\": \"PlainText\", \"content\": \"Hello!\"}, {\"contentType\": \"ImageResponseCard\", \"imageResponseCard\": {\"title\": \"Test\"}} ]''' messages = dialog.load_messages(messages_json) assert len(messages) == 2 assert isinstance(messages[0], LexPlainText) assert messages[0].content == \"Hello!\" def test_message_prepending(): \"\"\"Test that messages are properly prepended in transitions\"\"\" request_dict = create_test_request() lex_request = dialog.parse_lex_request(request_dict, CustomSessionAttributes()) input_messages = [LexPlainText(content=\"Transition message\")] # Mock the handler to return a response with messages def mock_handler(intent_name, lex_request): return dialog.LexResponse( sessionState=lex_request.sessionState, messages=[LexPlainText(content=\"Handler message\")], requestAttributes={} ) # Test message prepending response = dialog.transition_to_intent( intent_name=\"test_intent\", lex_request=lex_request, messages=input_messages ) # Input messages should come first assert len(response.messages) >= 1 assert response.messages[0].content == \"Transition message\"","title":"Testing Message Handling"},{"location":"TESTING_GUIDE/#testing-message-management","text":"Test localized messages and MessageManager functionality: def test_message_loading(): \"\"\"Test loading messages for different locales\"\"\" # Test English messages set_locale(\"en_US\") greeting = get_message(\"greeting\") assert \"Hello\" in greeting # Test Spanish messages set_locale(\"es_ES\") spanish_greeting = get_message(\"greeting\") assert \"Hola\" in spanish_greeting # Test fallback to default fallback_message = get_message(\"nonexistent.key\", \"Default message\") assert fallback_message == \"Default message\" def test_locale_override(): \"\"\"Test locale override in get_message\"\"\" set_locale(\"en_US\") # Get message in current locale english_msg = get_message(\"greeting\") # Override locale for specific message spanish_msg = get_message(\"greeting\", locale=\"es_ES\") assert english_msg != spanish_msg assert \"Hello\" in english_msg assert \"Hola\" in spanish_msg def test_message_manager_singleton(): \"\"\"Test MessageManager singleton behavior\"\"\" manager1 = MessageManager() manager2 = MessageManager() assert manager1 is manager2 # Test that locale changes affect all instances manager1.set_locale(\"fr_FR\") french_msg = manager2.get_message(\"greeting\") assert \"Bonjour\" in french_msg or \"greeting\" in french_msg # fallback def test_nested_message_keys(): \"\"\"Test nested message key access\"\"\" set_locale(\"en_US\") # Test nested key access agent_confirmation = get_message(\"agent.confirmation\") error_general = get_message(\"error.general\") assert agent_confirmation != \"Message not found: agent.confirmation\" assert error_general != \"Message not found: error.general\"","title":"Testing Message Management"},{"location":"TESTING_GUIDE/#running-tests","text":"Use pytest to run your tests: # Run all tests pytest tests/ # Run specific test file pytest tests/test_dialog_flows.py # Run with coverage pytest --cov=your_project tests/ # Run tests with verbose output pytest -v tests/","title":"Running Tests"},{"location":"TESTING_GUIDE/#test-organization","text":"Structure your tests to match your intent organization: tests/ \u251c\u2500\u2500 __init__.py \u251c\u2500\u2500 conftest.py # Shared fixtures \u251c\u2500\u2500 test_dialog_flows.py # Dialog flow tests \u251c\u2500\u2500 test_slot_validation.py # Slot validation tests \u251c\u2500\u2500 test_session_management.py # Session attribute tests \u2514\u2500\u2500 intents/ \u251c\u2500\u2500 test_booking_intent.py \u251c\u2500\u2500 test_welcome_intent.py \u2514\u2500\u2500 test_fallback_intent.py","title":"Test Organization"},{"location":"TESTING_GUIDE/#best-practices-for-testing","text":"Use fixtures for common test data and setup Test edge cases like empty inputs, invalid data, and error conditions Mock external dependencies to isolate your bot logic Test across channels by simulating different request attributes Validate error handling and fallback behaviors Test session state persistence and transitions Use descriptive test names that explain the scenario being tested This comprehensive testing approach ensures your Lex bot handles all dialog scenarios correctly and provides a reliable user experience.","title":"Best Practices for Testing"},{"location":"smart-disambiguation/","text":"Smart Disambiguation for lex-helper Overview Smart Disambiguation is an intelligent feature in lex-helper that helps resolve ambiguous user input by presenting clear options when Amazon Lex cannot confidently determine the user's intent. Instead of falling back to \"I didn't understand,\" the system analyzes confidence scores and presents relevant choices to guide users to their desired outcome. Table of Contents How It Works When Disambiguation Triggers Configuration Message Localization Integration Examples Best Practices Troubleshooting How It Works The Problem Traditional chatbots often respond with generic fallback messages when they can't determine user intent: User: \"I need help with my booking\" Bot: \"I didn't understand that. Could you please rephrase your request?\" The Solution Smart Disambiguation analyzes Lex's confidence scores and presents clear options: User: \"I need help with my booking\" Bot: \"I can help you with a couple of things. Which would you like to do?\" [Book a Flight] [Change Flight] Architecture The disambiguation system consists of three main components: DisambiguationAnalyzer - Analyzes confidence scores and determines when to disambiguate DisambiguationHandler - Generates user-friendly clarification responses Handler Pipeline Integration - Seamlessly integrates with existing lex-helper flow When Disambiguation Triggers Disambiguation triggers in two scenarios: 1. Low Confidence Scenario When the top intent has low confidence and multiple candidates exist: # Example: All intents have low confidence { \"TrackBaggage\": 0.25, \"ChangeFlight\": 0.23, \"CancelFlight\": 0.19 } # Result: Triggers disambiguation 2. Close Scores Scenario When multiple intents have similar confidence scores: # Example: Two intents are very close { \"BookFlight\": 0.45, \"ChangeFlight\": 0.42, \"CancelFlight\": 0.10 } # Result: Triggers disambiguation between BookFlight and ChangeFlight When It Doesn't Trigger When there's a clear winner: # Example: Clear winner { \"TrackBaggage\": 0.75, \"ChangeFlight\": 0.15, \"Authenticate\": 0.10 } # Result: Proceeds directly to TrackBaggage Configuration Basic Configuration Enable disambiguation with default settings: from lex_helper import Config, LexHelper from lex_helper.core.disambiguation.types import DisambiguationConfig config = Config( session_attributes=MySessionAttributes(), enable_disambiguation=True # Enable with defaults ) lex_helper = LexHelper(config=config) Advanced Configuration Customize disambiguation behavior: disambiguation_config = DisambiguationConfig( # Core thresholds confidence_threshold=0.4, # Trigger when top score < 0.4 similarity_threshold=0.15, # Trigger when top scores within 0.15 max_candidates=2, # Show max 2 options min_candidates=2, # Need at least 2 candidates # Intent groupings for better messages custom_intent_groups={ \"booking\": [\"BookFlight\", \"ChangeFlight\", \"CancelFlight\"], \"status\": [\"FlightDelayUpdate\", \"TrackBaggage\"], \"account\": [\"Authenticate\"] }, # Custom message keys for localization custom_messages={ # Direct intent pair mappings \"BookFlight_ChangeFlight\": \"disambiguation.airline.book_or_change\", # Intent group mappings \"disambiguation.booking\": \"disambiguation.airline.booking_options\", # General mappings \"disambiguation.two_options\": \"disambiguation.airline.two_options\" } ) config = Config( session_attributes=MySessionAttributes(), enable_disambiguation=True, disambiguation_config=disambiguation_config ) Bedrock-Powered Disambiguation For even more intelligent and contextual disambiguation, enable Amazon Bedrock integration: from lex_helper.core.disambiguation.types import ( BedrockDisambiguationConfig, DisambiguationConfig ) # Configure Bedrock for intelligent text generation bedrock_config = BedrockDisambiguationConfig( enabled=True, model_id=\"anthropic.claude-3-haiku-20240307-v1:0\", region_name=\"us-east-1\", max_tokens=150, temperature=0.3, system_prompt=( \"You are a helpful assistant that creates clear, concise \" \"disambiguation messages for chatbot users. Be friendly and natural.\" ), fallback_to_static=True, # Graceful fallback if Bedrock fails ) # Configure disambiguation with Bedrock disambiguation_config = DisambiguationConfig( confidence_threshold=0.5, max_candidates=2, bedrock_config=bedrock_config, # Enable Bedrock integration ) Benefits of Bedrock Integration: - Contextual messages : Acknowledges user's specific input - Natural language : More conversational than static templates - Smart button labels : Generates intuitive action text - Adaptive responses : Tailored to your domain and use case Example comparison: Static disambiguation: User: \"I need help with my flight\" Bot: \"I can help you with several things. What would you like to do?\" Buttons: [\"Book Flight\", \"Change Flight\", \"Cancel Flight\"] Bedrock-powered disambiguation: User: \"I need help with my flight\" Bot: \"I'd be happy to help with your flight! Are you looking to make changes to an existing booking or book a new flight?\" Buttons: [\"Modify existing booking\", \"Book new flight\"] Configuration Parameters Parameter Type Default Description confidence_threshold float 0.6 Minimum confidence to avoid disambiguation similarity_threshold float 0.15 Max difference between top scores to trigger max_candidates int 3 Maximum options to show users min_candidates int 2 Minimum candidates needed to trigger custom_intent_groups dict {} Related intent groupings custom_messages dict {} Custom message key mappings bedrock_config BedrockDisambiguationConfig disabled Bedrock integration settings Bedrock Configuration Parameters Parameter Type Default Description enabled bool False Enable Bedrock text generation model_id str claude-3-haiku Bedrock model to use region_name str us-east-1 AWS region for Bedrock max_tokens int 200 Maximum tokens for responses temperature float 0.3 Randomness (0.0-1.0, lower = more deterministic) system_prompt str default System prompt for the model fallback_to_static bool True Fall back to static messages if Bedrock fails Message Localization Message Key Mapping The system uses a hierarchical approach to find the right message: 1. Direct Intent Pair Mapping (Highest Priority) # For intents: [\"BookFlight\", \"ChangeFlight\"] # Creates key: \"BookFlight_ChangeFlight\" (alphabetically sorted) custom_messages = { \"BookFlight_ChangeFlight\": \"disambiguation.airline.book_or_change\" } 2. Intent Group Mapping (Medium Priority) # For intents in the \"booking\" group # Creates key: \"disambiguation.booking\" custom_messages = { \"disambiguation.booking\": \"disambiguation.airline.booking_options\" } 3. Default Mapping (Lowest Priority) # Falls back to default keys custom_messages = { \"disambiguation.two_options\": \"disambiguation.airline.two_options\" } Message Files Add disambiguation messages to your localization files: messages_en_US.yaml: disambiguation: # Default messages two_options: \"I can help you with two things. Which would you like to do?\" multiple_options: \"I can help you with several things. What would you like to do?\" # Custom airline messages airline: two_options: \"I can help you with a couple of things. Which would you like to do?\" booking_options: \"I can help you with flight bookings. Would you like to book, change, or cancel a flight?\" book_or_change: \"Would you like to book a new flight or change an existing one?\" messages_es_ES.yaml: disambiguation: two_options: \"Puedo ayudarte con dos cosas. \u00bfCu\u00e1l te gustar\u00eda hacer?\" multiple_options: \"Puedo ayudarte con varias cosas. \u00bfQu\u00e9 te gustar\u00eda hacer?\" airline: two_options: \"Puedo ayudarte con un par de cosas. \u00bfCu\u00e1l te gustar\u00eda hacer?\" booking_options: \"Puedo ayudarte con reservas de vuelos. \u00bfTe gustar\u00eda reservar, cambiar o cancelar un vuelo?\" book_or_change: \"\u00bfTe gustar\u00eda reservar un nuevo vuelo o cambiar uno existente?\" Integration Handler Pipeline Integration Disambiguation integrates seamlessly into the lex-helper pipeline: # When disambiguation is enabled, the handler pipeline becomes: handlers = [ disambiguation_intent_handler, # Added automatically regular_intent_handler # Existing handler ] Processing Flow Request Analysis - Analyzer examines Lex confidence scores Disambiguation Decision - Determines if disambiguation is needed Response Generation - Creates user-friendly options with buttons User Selection - Processes user's choice and routes to correct intent Conversation Flow Example User: \"I need help with my booking\" Bot: \"I can help you with a couple of things. Which would you like to do?\" [Book Flight] [Change Flight] User clicks [Change Flight] \u2192 User input appears as: \"Change Flight\" (not \"ChangeFlight\") Bot: \"What is your reservation number?\" This natural conversation flow ensures users see human-readable text throughout their interaction. Response Format Disambiguation responses include both text and interactive buttons: { \"messages\": [ { \"content\": \"I can help you with a couple of things. Which would you like to do?\", \"contentType\": \"PlainText\" }, { \"contentType\": \"ImageResponseCard\", \"imageResponseCard\": { \"title\": \"Please choose an option:\", \"subtitle\": \"Select what you'd like to do\", \"buttons\": [ {\"text\": \"Track Baggage\", \"value\": \"Track Baggage\"}, {\"text\": \"Change Flight\", \"value\": \"Change Flight\"} ] } } ] } Note : Button values use human-readable display names (e.g., \"Track Baggage\") rather than technical intent names (e.g., \"TrackBaggage\"). This ensures that when users click buttons, they see natural language as their input, creating a more conversational experience. ## Examples ### Example 1: Basic Setup ```python # Minimal setup - just enable disambiguation config = Config( session_attributes=MySessionAttributes(), enable_disambiguation=True ) lex_helper = LexHelper(config=config) Example 2: Airline Bot Setup (Complete Implementation) The examples/sample_airline_bot/ directory contains a complete working example with both static and Bedrock-powered disambiguation: # Environment-based configuration for flexibility enable_bedrock = os.getenv(\"ENABLE_BEDROCK_DISAMBIGUATION\", \"false\").lower() == \"true\" # Bedrock configuration (optional) bedrock_config = BedrockDisambiguationConfig( enabled=enable_bedrock, model_id=\"anthropic.claude-3-haiku-20240307-v1:0\", system_prompt=\"You are a helpful airline customer service assistant...\", fallback_to_static=True, ) # Full airline bot configuration disambiguation_config = DisambiguationConfig( confidence_threshold=0.4, max_candidates=2, custom_intent_groups={ \"booking\": [\"BookFlight\", \"ChangeFlight\", \"CancelFlight\"], \"status\": [\"FlightDelayUpdate\", \"TrackBaggage\"] }, custom_messages={ \"disambiguation.booking\": \"disambiguation.airline.booking_options\", \"disambiguation.status\": \"disambiguation.airline.status_options\", \"BookFlight_ChangeFlight\": \"disambiguation.airline.book_or_change\" }, bedrock_config=bedrock_config, # AI-powered enhancement ) config = Config( session_attributes=AirlineBotSessionAttributes(), package_name=\"fulfillment_function\", enable_disambiguation=True, disambiguation_config=disambiguation_config ) Usage: # Static disambiguation python lambda_function.py # Bedrock-powered disambiguation ENABLE_BEDROCK_DISAMBIGUATION=true python lambda_function.py Example 3: E-commerce Bot Setup disambiguation_config = DisambiguationConfig( confidence_threshold=0.5, custom_intent_groups={ \"shopping\": [\"SearchProducts\", \"AddToCart\", \"Checkout\"], \"account\": [\"Login\", \"Register\", \"ViewOrders\"], \"support\": [\"ContactSupport\", \"ReturnItem\", \"TrackOrder\"] }, custom_messages={ \"disambiguation.shopping\": \"ecommerce.shopping_options\", \"disambiguation.account\": \"ecommerce.account_options\", \"SearchProducts_AddToCart\": \"ecommerce.search_or_add\" } ) Best Practices 1. Threshold Configuration Conservative (0.6-0.8) : Only disambiguate when really unsure Moderate (0.4-0.5) : Good balance for most bots Aggressive (0.2-0.3) : Catch more ambiguous cases 2. Intent Grouping Group related intents for better user experience: # Good grouping - related functionality custom_intent_groups = { \"booking\": [\"BookFlight\", \"ChangeFlight\", \"CancelFlight\"], \"status\": [\"FlightStatus\", \"BaggageStatus\"] } # Avoid - unrelated intents custom_intent_groups = { \"mixed\": [\"BookFlight\", \"Weather\", \"Authenticate\"] # Don't do this } 3. Message Design Keep messages concise and clear Use action-oriented language Provide specific options rather than generic choices Test with real user scenarios 4. Localization Always use message keys instead of hardcoded text Provide translations for all supported locales Test disambiguation in each language Consider cultural differences in phrasing 5. Testing Test disambiguation with various scenarios: # Test cases to verify test_cases = [ # Low confidence scenario {\"TrackBaggage\": 0.25, \"ChangeFlight\": 0.23}, # Close scores scenario {\"BookFlight\": 0.45, \"ChangeFlight\": 0.42}, # Clear winner (should not disambiguate) {\"TrackBaggage\": 0.75, \"ChangeFlight\": 0.15}, # Single candidate (should not disambiguate) {\"BookFlight\": 0.30} ] Troubleshooting Common Issues 1. Disambiguation Not Triggering Problem : Expected disambiguation but got fallback instead. Solutions : - Check if enable_disambiguation=True in config - Verify confidence scores are within triggering range - Ensure minimum candidates requirement is met - Check if disambiguation components are properly imported 2. Wrong Message Displayed Problem : Generic message instead of custom message. Solutions : - Verify message keys exist in localization files - Check custom_messages mapping is correct - Ensure intent names match exactly (case-sensitive) - Verify locale is set correctly 3. Disambiguation Triggering Too Often Problem : Disambiguation shows for clear intent matches. Solutions : - Increase confidence_threshold (try 0.6 instead of 0.4) - Increase similarity_threshold (try 0.2 instead of 0.15) - Check Lex training data quality - Review intent utterance overlap Debug Information Enable detailed logging to troubleshoot: disambiguation_config = DisambiguationConfig( enable_logging=True, # Enable detailed logs # ... other config ) Check logs for: - Confidence scores extracted from Lex - Disambiguation decision reasoning - Message key resolution Performance Considerations Disambiguation adds minimal latency (~10-50ms) Message localization is cached by lex-helper Button rendering is handled by Lex UI Migration Guide From Regular lex-helper Update imports : from lex_helper.core.disambiguation.types import DisambiguationConfig Add configuration : config = Config( # ... existing config enable_disambiguation=True ) Add message keys to localization files Test thoroughly with existing intents Backward Compatibility Disambiguation is disabled by default Existing code works without changes No breaking changes to existing APIs Graceful fallback if disambiguation components unavailable API Reference DisambiguationConfig @dataclass class DisambiguationConfig: confidence_threshold: float = 0.6 max_candidates: int = 3 fallback_to_original: bool = True min_candidates: int = 2 similarity_threshold: float = 0.15 enable_logging: bool = True custom_intent_groups: dict[str, list[str]] = field(default_factory=dict) custom_messages: dict[str, str] = field(default_factory=dict) Config Integration class Config: # ... existing fields enable_disambiguation: bool = False disambiguation_config: DisambiguationConfig | None = None Conclusion Smart Disambiguation transforms ambiguous user interactions into clear, actionable choices. By leveraging Lex's confidence scores, it significantly improves user experience while maintaining the simplicity and power of lex-helper. The feature is designed to be: - Easy to integrate - Just set enable_disambiguation=True - Highly configurable - Customize thresholds, messages, and behavior - Fully localized - Support for multiple languages out of the box - Backward compatible - No impact on existing implementations Start with the basic configuration and gradually customize based on your bot's specific needs and user feedback.","title":"Smart Disambiguation for lex-helper"},{"location":"smart-disambiguation/#smart-disambiguation-for-lex-helper","text":"","title":"Smart Disambiguation for lex-helper"},{"location":"smart-disambiguation/#overview","text":"Smart Disambiguation is an intelligent feature in lex-helper that helps resolve ambiguous user input by presenting clear options when Amazon Lex cannot confidently determine the user's intent. Instead of falling back to \"I didn't understand,\" the system analyzes confidence scores and presents relevant choices to guide users to their desired outcome.","title":"Overview"},{"location":"smart-disambiguation/#table-of-contents","text":"How It Works When Disambiguation Triggers Configuration Message Localization Integration Examples Best Practices Troubleshooting","title":"Table of Contents"},{"location":"smart-disambiguation/#how-it-works","text":"","title":"How It Works"},{"location":"smart-disambiguation/#the-problem","text":"Traditional chatbots often respond with generic fallback messages when they can't determine user intent: User: \"I need help with my booking\" Bot: \"I didn't understand that. Could you please rephrase your request?\"","title":"The Problem"},{"location":"smart-disambiguation/#the-solution","text":"Smart Disambiguation analyzes Lex's confidence scores and presents clear options: User: \"I need help with my booking\" Bot: \"I can help you with a couple of things. Which would you like to do?\" [Book a Flight] [Change Flight]","title":"The Solution"},{"location":"smart-disambiguation/#architecture","text":"The disambiguation system consists of three main components: DisambiguationAnalyzer - Analyzes confidence scores and determines when to disambiguate DisambiguationHandler - Generates user-friendly clarification responses Handler Pipeline Integration - Seamlessly integrates with existing lex-helper flow","title":"Architecture"},{"location":"smart-disambiguation/#when-disambiguation-triggers","text":"Disambiguation triggers in two scenarios:","title":"When Disambiguation Triggers"},{"location":"smart-disambiguation/#1-low-confidence-scenario","text":"When the top intent has low confidence and multiple candidates exist: # Example: All intents have low confidence { \"TrackBaggage\": 0.25, \"ChangeFlight\": 0.23, \"CancelFlight\": 0.19 } # Result: Triggers disambiguation","title":"1. Low Confidence Scenario"},{"location":"smart-disambiguation/#2-close-scores-scenario","text":"When multiple intents have similar confidence scores: # Example: Two intents are very close { \"BookFlight\": 0.45, \"ChangeFlight\": 0.42, \"CancelFlight\": 0.10 } # Result: Triggers disambiguation between BookFlight and ChangeFlight","title":"2. Close Scores Scenario"},{"location":"smart-disambiguation/#when-it-doesnt-trigger","text":"When there's a clear winner: # Example: Clear winner { \"TrackBaggage\": 0.75, \"ChangeFlight\": 0.15, \"Authenticate\": 0.10 } # Result: Proceeds directly to TrackBaggage","title":"When It Doesn't Trigger"},{"location":"smart-disambiguation/#configuration","text":"","title":"Configuration"},{"location":"smart-disambiguation/#basic-configuration","text":"Enable disambiguation with default settings: from lex_helper import Config, LexHelper from lex_helper.core.disambiguation.types import DisambiguationConfig config = Config( session_attributes=MySessionAttributes(), enable_disambiguation=True # Enable with defaults ) lex_helper = LexHelper(config=config)","title":"Basic Configuration"},{"location":"smart-disambiguation/#advanced-configuration","text":"Customize disambiguation behavior: disambiguation_config = DisambiguationConfig( # Core thresholds confidence_threshold=0.4, # Trigger when top score < 0.4 similarity_threshold=0.15, # Trigger when top scores within 0.15 max_candidates=2, # Show max 2 options min_candidates=2, # Need at least 2 candidates # Intent groupings for better messages custom_intent_groups={ \"booking\": [\"BookFlight\", \"ChangeFlight\", \"CancelFlight\"], \"status\": [\"FlightDelayUpdate\", \"TrackBaggage\"], \"account\": [\"Authenticate\"] }, # Custom message keys for localization custom_messages={ # Direct intent pair mappings \"BookFlight_ChangeFlight\": \"disambiguation.airline.book_or_change\", # Intent group mappings \"disambiguation.booking\": \"disambiguation.airline.booking_options\", # General mappings \"disambiguation.two_options\": \"disambiguation.airline.two_options\" } ) config = Config( session_attributes=MySessionAttributes(), enable_disambiguation=True, disambiguation_config=disambiguation_config )","title":"Advanced Configuration"},{"location":"smart-disambiguation/#bedrock-powered-disambiguation","text":"For even more intelligent and contextual disambiguation, enable Amazon Bedrock integration: from lex_helper.core.disambiguation.types import ( BedrockDisambiguationConfig, DisambiguationConfig ) # Configure Bedrock for intelligent text generation bedrock_config = BedrockDisambiguationConfig( enabled=True, model_id=\"anthropic.claude-3-haiku-20240307-v1:0\", region_name=\"us-east-1\", max_tokens=150, temperature=0.3, system_prompt=( \"You are a helpful assistant that creates clear, concise \" \"disambiguation messages for chatbot users. Be friendly and natural.\" ), fallback_to_static=True, # Graceful fallback if Bedrock fails ) # Configure disambiguation with Bedrock disambiguation_config = DisambiguationConfig( confidence_threshold=0.5, max_candidates=2, bedrock_config=bedrock_config, # Enable Bedrock integration ) Benefits of Bedrock Integration: - Contextual messages : Acknowledges user's specific input - Natural language : More conversational than static templates - Smart button labels : Generates intuitive action text - Adaptive responses : Tailored to your domain and use case Example comparison: Static disambiguation: User: \"I need help with my flight\" Bot: \"I can help you with several things. What would you like to do?\" Buttons: [\"Book Flight\", \"Change Flight\", \"Cancel Flight\"] Bedrock-powered disambiguation: User: \"I need help with my flight\" Bot: \"I'd be happy to help with your flight! Are you looking to make changes to an existing booking or book a new flight?\" Buttons: [\"Modify existing booking\", \"Book new flight\"]","title":"Bedrock-Powered Disambiguation"},{"location":"smart-disambiguation/#configuration-parameters","text":"Parameter Type Default Description confidence_threshold float 0.6 Minimum confidence to avoid disambiguation similarity_threshold float 0.15 Max difference between top scores to trigger max_candidates int 3 Maximum options to show users min_candidates int 2 Minimum candidates needed to trigger custom_intent_groups dict {} Related intent groupings custom_messages dict {} Custom message key mappings bedrock_config BedrockDisambiguationConfig disabled Bedrock integration settings","title":"Configuration Parameters"},{"location":"smart-disambiguation/#bedrock-configuration-parameters","text":"Parameter Type Default Description enabled bool False Enable Bedrock text generation model_id str claude-3-haiku Bedrock model to use region_name str us-east-1 AWS region for Bedrock max_tokens int 200 Maximum tokens for responses temperature float 0.3 Randomness (0.0-1.0, lower = more deterministic) system_prompt str default System prompt for the model fallback_to_static bool True Fall back to static messages if Bedrock fails","title":"Bedrock Configuration Parameters"},{"location":"smart-disambiguation/#message-localization","text":"","title":"Message Localization"},{"location":"smart-disambiguation/#message-key-mapping","text":"The system uses a hierarchical approach to find the right message:","title":"Message Key Mapping"},{"location":"smart-disambiguation/#1-direct-intent-pair-mapping-highest-priority","text":"# For intents: [\"BookFlight\", \"ChangeFlight\"] # Creates key: \"BookFlight_ChangeFlight\" (alphabetically sorted) custom_messages = { \"BookFlight_ChangeFlight\": \"disambiguation.airline.book_or_change\" }","title":"1. Direct Intent Pair Mapping (Highest Priority)"},{"location":"smart-disambiguation/#2-intent-group-mapping-medium-priority","text":"# For intents in the \"booking\" group # Creates key: \"disambiguation.booking\" custom_messages = { \"disambiguation.booking\": \"disambiguation.airline.booking_options\" }","title":"2. Intent Group Mapping (Medium Priority)"},{"location":"smart-disambiguation/#3-default-mapping-lowest-priority","text":"# Falls back to default keys custom_messages = { \"disambiguation.two_options\": \"disambiguation.airline.two_options\" }","title":"3. Default Mapping (Lowest Priority)"},{"location":"smart-disambiguation/#message-files","text":"Add disambiguation messages to your localization files: messages_en_US.yaml: disambiguation: # Default messages two_options: \"I can help you with two things. Which would you like to do?\" multiple_options: \"I can help you with several things. What would you like to do?\" # Custom airline messages airline: two_options: \"I can help you with a couple of things. Which would you like to do?\" booking_options: \"I can help you with flight bookings. Would you like to book, change, or cancel a flight?\" book_or_change: \"Would you like to book a new flight or change an existing one?\" messages_es_ES.yaml: disambiguation: two_options: \"Puedo ayudarte con dos cosas. \u00bfCu\u00e1l te gustar\u00eda hacer?\" multiple_options: \"Puedo ayudarte con varias cosas. \u00bfQu\u00e9 te gustar\u00eda hacer?\" airline: two_options: \"Puedo ayudarte con un par de cosas. \u00bfCu\u00e1l te gustar\u00eda hacer?\" booking_options: \"Puedo ayudarte con reservas de vuelos. \u00bfTe gustar\u00eda reservar, cambiar o cancelar un vuelo?\" book_or_change: \"\u00bfTe gustar\u00eda reservar un nuevo vuelo o cambiar uno existente?\"","title":"Message Files"},{"location":"smart-disambiguation/#integration","text":"","title":"Integration"},{"location":"smart-disambiguation/#handler-pipeline-integration","text":"Disambiguation integrates seamlessly into the lex-helper pipeline: # When disambiguation is enabled, the handler pipeline becomes: handlers = [ disambiguation_intent_handler, # Added automatically regular_intent_handler # Existing handler ]","title":"Handler Pipeline Integration"},{"location":"smart-disambiguation/#processing-flow","text":"Request Analysis - Analyzer examines Lex confidence scores Disambiguation Decision - Determines if disambiguation is needed Response Generation - Creates user-friendly options with buttons User Selection - Processes user's choice and routes to correct intent","title":"Processing Flow"},{"location":"smart-disambiguation/#conversation-flow-example","text":"User: \"I need help with my booking\" Bot: \"I can help you with a couple of things. Which would you like to do?\" [Book Flight] [Change Flight] User clicks [Change Flight] \u2192 User input appears as: \"Change Flight\" (not \"ChangeFlight\") Bot: \"What is your reservation number?\" This natural conversation flow ensures users see human-readable text throughout their interaction.","title":"Conversation Flow Example"},{"location":"smart-disambiguation/#response-format","text":"Disambiguation responses include both text and interactive buttons: { \"messages\": [ { \"content\": \"I can help you with a couple of things. Which would you like to do?\", \"contentType\": \"PlainText\" }, { \"contentType\": \"ImageResponseCard\", \"imageResponseCard\": { \"title\": \"Please choose an option:\", \"subtitle\": \"Select what you'd like to do\", \"buttons\": [ {\"text\": \"Track Baggage\", \"value\": \"Track Baggage\"}, {\"text\": \"Change Flight\", \"value\": \"Change Flight\"} ] } } ] } Note : Button values use human-readable display names (e.g., \"Track Baggage\") rather than technical intent names (e.g., \"TrackBaggage\"). This ensures that when users click buttons, they see natural language as their input, creating a more conversational experience. ## Examples ### Example 1: Basic Setup ```python # Minimal setup - just enable disambiguation config = Config( session_attributes=MySessionAttributes(), enable_disambiguation=True ) lex_helper = LexHelper(config=config)","title":"Response Format"},{"location":"smart-disambiguation/#example-2-airline-bot-setup-complete-implementation","text":"The examples/sample_airline_bot/ directory contains a complete working example with both static and Bedrock-powered disambiguation: # Environment-based configuration for flexibility enable_bedrock = os.getenv(\"ENABLE_BEDROCK_DISAMBIGUATION\", \"false\").lower() == \"true\" # Bedrock configuration (optional) bedrock_config = BedrockDisambiguationConfig( enabled=enable_bedrock, model_id=\"anthropic.claude-3-haiku-20240307-v1:0\", system_prompt=\"You are a helpful airline customer service assistant...\", fallback_to_static=True, ) # Full airline bot configuration disambiguation_config = DisambiguationConfig( confidence_threshold=0.4, max_candidates=2, custom_intent_groups={ \"booking\": [\"BookFlight\", \"ChangeFlight\", \"CancelFlight\"], \"status\": [\"FlightDelayUpdate\", \"TrackBaggage\"] }, custom_messages={ \"disambiguation.booking\": \"disambiguation.airline.booking_options\", \"disambiguation.status\": \"disambiguation.airline.status_options\", \"BookFlight_ChangeFlight\": \"disambiguation.airline.book_or_change\" }, bedrock_config=bedrock_config, # AI-powered enhancement ) config = Config( session_attributes=AirlineBotSessionAttributes(), package_name=\"fulfillment_function\", enable_disambiguation=True, disambiguation_config=disambiguation_config ) Usage: # Static disambiguation python lambda_function.py # Bedrock-powered disambiguation ENABLE_BEDROCK_DISAMBIGUATION=true python lambda_function.py","title":"Example 2: Airline Bot Setup (Complete Implementation)"},{"location":"smart-disambiguation/#example-3-e-commerce-bot-setup","text":"disambiguation_config = DisambiguationConfig( confidence_threshold=0.5, custom_intent_groups={ \"shopping\": [\"SearchProducts\", \"AddToCart\", \"Checkout\"], \"account\": [\"Login\", \"Register\", \"ViewOrders\"], \"support\": [\"ContactSupport\", \"ReturnItem\", \"TrackOrder\"] }, custom_messages={ \"disambiguation.shopping\": \"ecommerce.shopping_options\", \"disambiguation.account\": \"ecommerce.account_options\", \"SearchProducts_AddToCart\": \"ecommerce.search_or_add\" } )","title":"Example 3: E-commerce Bot Setup"},{"location":"smart-disambiguation/#best-practices","text":"","title":"Best Practices"},{"location":"smart-disambiguation/#1-threshold-configuration","text":"Conservative (0.6-0.8) : Only disambiguate when really unsure Moderate (0.4-0.5) : Good balance for most bots Aggressive (0.2-0.3) : Catch more ambiguous cases","title":"1. Threshold Configuration"},{"location":"smart-disambiguation/#2-intent-grouping","text":"Group related intents for better user experience: # Good grouping - related functionality custom_intent_groups = { \"booking\": [\"BookFlight\", \"ChangeFlight\", \"CancelFlight\"], \"status\": [\"FlightStatus\", \"BaggageStatus\"] } # Avoid - unrelated intents custom_intent_groups = { \"mixed\": [\"BookFlight\", \"Weather\", \"Authenticate\"] # Don't do this }","title":"2. Intent Grouping"},{"location":"smart-disambiguation/#3-message-design","text":"Keep messages concise and clear Use action-oriented language Provide specific options rather than generic choices Test with real user scenarios","title":"3. Message Design"},{"location":"smart-disambiguation/#4-localization","text":"Always use message keys instead of hardcoded text Provide translations for all supported locales Test disambiguation in each language Consider cultural differences in phrasing","title":"4. Localization"},{"location":"smart-disambiguation/#5-testing","text":"Test disambiguation with various scenarios: # Test cases to verify test_cases = [ # Low confidence scenario {\"TrackBaggage\": 0.25, \"ChangeFlight\": 0.23}, # Close scores scenario {\"BookFlight\": 0.45, \"ChangeFlight\": 0.42}, # Clear winner (should not disambiguate) {\"TrackBaggage\": 0.75, \"ChangeFlight\": 0.15}, # Single candidate (should not disambiguate) {\"BookFlight\": 0.30} ]","title":"5. Testing"},{"location":"smart-disambiguation/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"smart-disambiguation/#common-issues","text":"","title":"Common Issues"},{"location":"smart-disambiguation/#1-disambiguation-not-triggering","text":"Problem : Expected disambiguation but got fallback instead. Solutions : - Check if enable_disambiguation=True in config - Verify confidence scores are within triggering range - Ensure minimum candidates requirement is met - Check if disambiguation components are properly imported","title":"1. Disambiguation Not Triggering"},{"location":"smart-disambiguation/#2-wrong-message-displayed","text":"Problem : Generic message instead of custom message. Solutions : - Verify message keys exist in localization files - Check custom_messages mapping is correct - Ensure intent names match exactly (case-sensitive) - Verify locale is set correctly","title":"2. Wrong Message Displayed"},{"location":"smart-disambiguation/#3-disambiguation-triggering-too-often","text":"Problem : Disambiguation shows for clear intent matches. Solutions : - Increase confidence_threshold (try 0.6 instead of 0.4) - Increase similarity_threshold (try 0.2 instead of 0.15) - Check Lex training data quality - Review intent utterance overlap","title":"3. Disambiguation Triggering Too Often"},{"location":"smart-disambiguation/#debug-information","text":"Enable detailed logging to troubleshoot: disambiguation_config = DisambiguationConfig( enable_logging=True, # Enable detailed logs # ... other config ) Check logs for: - Confidence scores extracted from Lex - Disambiguation decision reasoning - Message key resolution","title":"Debug Information"},{"location":"smart-disambiguation/#performance-considerations","text":"Disambiguation adds minimal latency (~10-50ms) Message localization is cached by lex-helper Button rendering is handled by Lex UI","title":"Performance Considerations"},{"location":"smart-disambiguation/#migration-guide","text":"","title":"Migration Guide"},{"location":"smart-disambiguation/#from-regular-lex-helper","text":"Update imports : from lex_helper.core.disambiguation.types import DisambiguationConfig Add configuration : config = Config( # ... existing config enable_disambiguation=True ) Add message keys to localization files Test thoroughly with existing intents","title":"From Regular lex-helper"},{"location":"smart-disambiguation/#backward-compatibility","text":"Disambiguation is disabled by default Existing code works without changes No breaking changes to existing APIs Graceful fallback if disambiguation components unavailable","title":"Backward Compatibility"},{"location":"smart-disambiguation/#api-reference","text":"","title":"API Reference"},{"location":"smart-disambiguation/#disambiguationconfig","text":"@dataclass class DisambiguationConfig: confidence_threshold: float = 0.6 max_candidates: int = 3 fallback_to_original: bool = True min_candidates: int = 2 similarity_threshold: float = 0.15 enable_logging: bool = True custom_intent_groups: dict[str, list[str]] = field(default_factory=dict) custom_messages: dict[str, str] = field(default_factory=dict)","title":"DisambiguationConfig"},{"location":"smart-disambiguation/#config-integration","text":"class Config: # ... existing fields enable_disambiguation: bool = False disambiguation_config: DisambiguationConfig | None = None","title":"Config Integration"},{"location":"smart-disambiguation/#conclusion","text":"Smart Disambiguation transforms ambiguous user interactions into clear, actionable choices. By leveraging Lex's confidence scores, it significantly improves user experience while maintaining the simplicity and power of lex-helper. The feature is designed to be: - Easy to integrate - Just set enable_disambiguation=True - Highly configurable - Customize thresholds, messages, and behavior - Fully localized - Support for multiple languages out of the box - Backward compatible - No impact on existing implementations Start with the basic configuration and gradually customize based on your bot's specific needs and user feedback.","title":"Conclusion"}]}